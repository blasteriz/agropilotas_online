<!DOCTYPE html>
<html lang="lt">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport"/>
  <title>
   AgroPilotas – Vairavimo simuliatorius (klaviatūra) v22 – A/B single button &amp; collapse fix
  </title>
  <style>
   html, body {
            margin: 0;
            height: 100%;
            overflow: hidden;
            background: #071309;
            color: #e9f5ea;
            font-family: Segoe UI,Roboto,Arial,sans-serif
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background: #0e3a14;
            touch-action: none
        }

        /* HUD */
        .hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 12px 12px 18px;
            background: rgba(0,0,0,.32);
            backdrop-filter: blur(8px) saturate(1.05);
            -webkit-backdrop-filter: blur(8px) saturate(1.05);
            border-bottom: 1px solid rgba(255,255,255,.14);
            box-shadow: 0 8px 24px rgba(0,0,0,.25);
            z-index: 5;
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow: visible
        }

        .hud-bottom {
            top: auto;
            bottom: 0;
            border-bottom: 0 !important;
            border-top: 1px solid rgba(255,255,255,.14) !important;
            padding: 18px 12px 12px;
            align-items: center
        }

        .hud-bottom .chips {
            justify-content: center
        }

        .hud-row {
            display: none
        }

        .stats-row {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 4px;
            position: relative;
            z-index: 2
        }

        

        .ledbar-wrap {
            display: flex;
            justify-content: center;
            margin-top: 6px
        }

        .ledbar {
            display: flex;
            align-items: center;
            gap: 8px
        }

        /* LED lightbar */
        .ledstrip {
            display: flex;
            gap: 2px;
            align-items: center
        }

            .ledstrip.left {
                flex-direction: row-reverse;
                justify-content: flex-start
            }

            .ledstrip.right {
                justify-content: flex-start
            }

        .led {
            width: 16px;
            height: 24px;
            border-radius: 6px;
            opacity: .28;
            background: #3c3c3c;
            box-shadow: inset 0 1px 2px rgba(0,0,0,.6)
        }

            .led.on {
                opacity: 1
            }

            .led.g {
                background: #38d06c;
                box-shadow: 0 0 8px rgba(56,208,108,.8)
            }

            .led.y {
                background: #ffd54f;
                box-shadow: 0 0 8px rgba(255,213,79,.8)
            }

            .led.r {
                background: #ff5d73;
                box-shadow: 0 0 8px rgba(255,93,115,.8)
            }



        .stat {
            background: rgba(255,255,255,.08);
            border: 1px solid rgba(255,255,255,.15);
            padding: 6px 10px;
            border-radius: 10px;
            font-size: 13px
        }

        .label {
            opacity: .9
        }

        .val {
            font-weight: 700;
            margin-left: 6px
        }

        /* Controls row */
        .controls {
            flex-wrap: nowrap;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            gap: 8px;
            align-items: center;
            justify-content: flex-start;
            margin-top: 6px;
            display: flex;
            position: relative;
            z-index: 3
        }

            .controls::-webkit-scrollbar {
                display: none
            }

        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            background: #2b5cff;
            color: #fff;
            font-weight: 700;
            box-shadow: 0 8px 18px rgba(43,92,255,.35)
        }

        /* Hide deprecated Clear Coverage button */
        #btnClearTrail { display: none !important; }

            .btn.ghost {
                background: transparent;
                border: 1px solid rgba(255,255,255,.3);
                color: #d9e5ff;
                box-shadow: none
            }

            .btn.on {
                background: #00c853;
                box-shadow: 0 8px 18px rgba(0,200,83,.45)
            }

        /* Android-like toggle styling for buttons that represent ON/OFF */
        .btn.toggle {
            position: relative;
            background: rgba(255,255,255,.10);
            box-shadow: none;
            padding-right: 64px; /* room for switch */
            overflow: hidden; /* keep knob within */
        }
        .btn.toggle.on { background: rgba(255,255,255,.14); }
        .btn.toggle::before {
            content: '';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 46px;
            height: 26px;
            border-radius: 9999px;
            background: rgba(150,150,160,.45);
            transition: background .18s ease, box-shadow .18s ease;
            box-shadow: inset 0 2px 4px rgba(0,0,0,.25);
        }
        .btn.toggle::after {
            content: '';
            position: absolute;
            right: 10px;
            top: 50%;
            /* position knob inside track: left when OFF, right when ON */
            transform: translate(-24px, -50%);
            width: 22px;
            height: 22px;
            border-radius: 9999px;
            background: #fff;
            box-shadow: 0 2px 6px rgba(0,0,0,.3);
            transition: transform .18s ease;
        }
        .btn.toggle.on::before { background: #34C759; }
        .btn.toggle.on::after { transform: translate(0, -50%); }

        input[type="number"] {
            width: 100px;
            padding: 8px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,.3);
            background: rgba(0,0,0,.2);
            color: #e9f5ea
        }

        /* Collapsible groups */
        .group {
            display: flex;
            flex-direction: column;
            min-width: max-content
        }

        .group-body {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: rgba(255,255,255,.08);
            border: 1px solid rgba(255,255,255,.18);
            border-radius: 12px;
            margin-top: 6px
        }
        /* Icons inside group toggle buttons */
        .group-toggle .ico {
            width: 18px;
            height: 18px;
            margin-right: 8px;
            vertical-align: middle;
            opacity: .95;
            color: inherit; /* follow theme (day: black, night: white) */
        }
            /* ensure [hidden] actually hides despite .group-body display:flex */
            .group-body[hidden] {
                display: none !important;
            }

        .group .stat {
            background: transparent;
            border: 1px solid rgba(255,255,255,.25)
        }

        .zoom-row {
            display: flex;
            gap: 8px
        }

        /* Robust icons for group buttons via CSS, independent of innerHTML */
        .group-toggle { position: relative; padding-left: 36px; }
        .group-toggle::before {
            content: '';
            position: absolute;
            left: 10px; top: 50%; transform: translateY(-50%);
            width: 18px; height: 18px; opacity: .95;
            background-size: contain; background-repeat: no-repeat; background-position: center;
            filter: drop-shadow(0 1px 1px rgba(0,0,0,.25));
        }
        /* Gairės */
        #btnGuideSettings.group-toggle::before {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cline x1='4' y1='8' x2='20' y2='8'/%3E%3Cline x1='4' y1='12' x2='20' y2='12'/%3E%3Cline x1='4' y1='16' x2='20' y2='16'/%3E%3Ctext x='3' y='8' dy='3' font-size='7' fill='currentColor'%3EA%3C/text%3E%3Ctext x='18' y='16' dy='3' font-size='7' fill='currentColor'%3EB%3C/text%3E%3C/svg%3E");
        }
        /* Padargas */
        #btnImplSettings.group-toggle::before {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M4 8H20'/%3E%3Cpath d='M6 10v2M10 10v2M14 10v2M18 10v2'/%3E%3C/svg%3E");
        }
        /* Žemėlapis */
        #btnMapSettings.group-toggle::before {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M3 6l6-2 6 2 6-2v14l-6 2-6-2-6 2z'/%3E%3Cpath d='M9 4v16M15 6v16'/%3E%3C/svg%3E");
        }

        /* Number input spin controls */
        .num-spin {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .btn.spin {
            padding: 4px 10px;
            line-height: 1;
            font-weight: 800;
        }
        .group-body input[type="number"] {
            width: 90px;
        }

        /* Hint */
        .hint {
            position: absolute;
            left: 12px;
            bottom: calc(12px + env(safe-area-inset-bottom,0px));
            background: rgba(0,0,0,.35);
            border: 1px solid rgba(255,255,255,.18);
            padding: 10px 12px;
            border-radius: 12px;
            font-size: 12px;
            line-height: 1.45;
            z-index: 8
        }

        /* On-screen driving controls */
        :root {
            --btn-size: clamp(44px, 9vh, 68px);
            --controls-bottom: max(18px, env(safe-area-inset-bottom,0px));
            --controls-raise: 56px
        }

        .steer-controls {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: calc(var(--controls-bottom) + var(--controls-raise));
            display: grid;
            grid-template-columns: repeat(3,var(--btn-size));
            grid-auto-rows: var(--btn-size);
            gap: 6px;
            justify-content: center;
            align-items: center;
            z-index: 6
        }

        .steer-btn {
            width: var(--btn-size);
            height: var(--btn-size);
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,.25);
            background: rgba(255,255,255,.12);
            color: #e9f5ea;
            font-weight: 900;
            font-size: calc(var(--btn-size)*0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 22px rgba(0,0,0,.35);
            backdrop-filter: blur(4px);
            cursor: pointer;
            user-select: none;
            touch-action: none
        }

            .steer-btn.on {
                background: #00c853;
                box-shadow: 0 8px 22px rgba(0,200,83,.45)
            }

            .steer-btn:active {
                transform: scale(.98)
            }
        /* Classic keyboard inverted-T (no hole in the middle) */
        #btnFwd {
            grid-column: 2;
            grid-row: 1
        }

        #btnSteerLeft {
            grid-column: 1;
            grid-row: 2
        }

        #btnSteerRight {
            grid-column: 3;
            grid-row: 2
        }

        #btnBack {
            grid-column: 2;
            grid-row: 3
        }
        /* Responsive downsizing for small screens */
        @media (max-height: 620px) {
            :root {
                --btn-size: 60px
            }
        }

        @media (max-height: 520px) {
            :root {
                --btn-size: 52px
            }
        }

        @media (max-height: 460px) {
            :root {
                --btn-size: 44px
            }
        }

        @media (max-width: 360px) {
            :root {
                --btn-size: 48px
            }
        }

        /* Floating round action button (A/B marks) */
        .fab {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 7;
            background: #1e88e5;
            color: #fff;
            border: none;
            border-radius: 9999px;
            box-shadow: 0 10px 24px rgba(0,0,0,.35);
            padding: 10px 14px;
            font-weight: 800;
            cursor: pointer
        }

            .fab.left {
                left: 12px
            }

            .fab.right {
                right: 12px
            }

            .fab.small {
                font-size: 13px;
                padding: 8px 12px
            }

            /* FAB color states for A/B flow */
            .fab.fab-b { /* Pažymėti B? */
                background: #00c853;
                box-shadow: 0 10px 24px rgba(0,200,83,.45), 0 0 0 4px rgba(0,200,83,.18);
            }

            .fab.fab-a-attn { /* Pažymėti A after saving B -> attention */
                background: #ff5252;
                box-shadow: 0 10px 24px rgba(255,82,82,.45), 0 0 0 4px rgba(255,82,82,.22);
            }

        @media (max-width: 900px) {
            .fab {
                padding: 8px 12px;
                font-size: 13px
            }
        }

        @media (max-width: 600px) {
            .fab {
                padding: 6px 10px;
                font-size: 12px
            }
        }

        /* High-visibility overrides (v22.1) */
        .hud {
            background: linear-gradient(180deg,rgba(0,0,0,.35),rgba(0,0,0,.12))
        }

        .stat {
            background: rgba(255,255,255,.18);
            border-color: rgba(255,255,255,.45);
            color: #fff
        }

        .btn {
            background: #5a7dff;
            box-shadow: 0 12px 24px rgba(90,125,255,.45);
            font-weight: 800
        }

            .btn.ghost {
                background: rgba(255,255,255,.12);
                color: #fff;
                border-color: rgba(255,255,255,.5)
            }

        canvas {
            background: #1b7a33
        }
        
        /* Hide the old toolbar implement button */
        .controls #btnImpl {
            display: none !important;
        }

        /* Visually remove specific Map menu buttons (logic remains) */
        #btnFollow,
        #btnRotate,
        #btnLowPower {
            display: none !important;
        }

        /* Floating Implement toggle (right side, big, with icon) */
        .apply-toggle {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            width: 82px;
            height: 82px;
            border-radius: 9999px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,.12);
            color: #fff;
            border: 1px solid rgba(255,255,255,.35);
            box-shadow: 0 14px 26px rgba(0,0,0,.35);
            cursor: pointer;
            user-select: none;
            z-index: 8;
            touch-action: manipulation;
        }

            .apply-toggle .icon {
                width: 36px;
                height: 36px;
                opacity: .95
            }


            /* ON/OFF visuals */
            .apply-toggle.on {
                background: #00c853;
                border-color: rgba(0,0,0,.15);
                box-shadow: 0 0 0 5px rgba(0,200,83,.2), 0 18px 30px rgba(0,0,0,.4);
            }

            .apply-toggle.off {
                background: rgba(255,255,255,.12);
            }

        /* Smaller on phones */
        @media (max-width: 700px) {
            .apply-toggle {
                width: 68px;
                height: 68px;
                right: 10px
            }

                .apply-toggle .icon {
                    width: 30px;
                    height: 30px
                }
        }
        /* Bigger LED bar + CTE readout */
        .ledbar {
            gap: 12px;
            transform: scale(1.35);
            transform-origin: center top
        }

        /* Floating Zoom controls (top-right) */
        .zoom-stack {
            position: absolute;
            right: 14px;
            top: 14px;
            display: flex;
            flex-direction: column;
            align-items: flex-end; /* align groups to right edge */
            gap: 8px;
            z-index: 9;
        }
        .zoom-btn {
            width: 44px;
            height: 44px;
            border-radius: 9999px;
            display: grid;
            place-items: center;
            background: rgba(0,0,0,.35);
            color: #fff;
            border: 1px solid rgba(255,255,255,.35);
            box-shadow: 0 10px 20px rgba(0,0,0,.35);
            cursor: pointer;
            user-select: none;
        }
        .zoom-btn svg { width: 22px; height: 22px; opacity: .95; }
        .zoom-group { display: flex; align-items: center; justify-content: flex-end; gap: 8px; cursor: pointer; }
        .zoom-label {
            color: #fff;
            font-size: 12px;
            font-weight: 700;
            background: rgba(0,0,0,.35);
            border: 1px solid rgba(255,255,255,.35);
            padding: 4px 8px;
            border-radius: 10px;
            user-select: none;
            white-space: nowrap;
            text-align: right;
            width: auto; /* fit text width */
            cursor: pointer;
        }
        @media (max-width: 700px) {
            .zoom-btn { width: 40px; height: 40px; }
            .zoom-btn svg { width: 20px; height: 20px; }
            .zoom-label { font-size: 11px; padding: 3px 6px; width: auto; }
        }

        .cte-block {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px
        }

        .cte-readout {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 900;
            font-size: 30px;
            line-height: 1;
            letter-spacing: .4px
        }

            .cte-readout .num {
                min-width: 90px;
                text-align: center
            }

            .cte-readout .arrow {
                font-size: 30px;
                opacity: .35;
                user-select: none;
                transition: transform .1s ease, opacity .1s ease, color .1s ease;
                color: #ffffff
            }

                .cte-readout .arrow.active {
                    opacity: 1;
                    transform: scale(1.15)
                }

        @media (max-width:900px) {

            .cte-readout {
                font-size: 24px
            }

                .cte-readout .num {
                    min-width: 70px
                }

                .cte-readout .arrow {
                    font-size: 24px
                }

            .led {
                width: 12px;
                height: 18px;
                border-radius: 5px
            }
        }

        .cte-readout .arrow.g {
            color: #38d06c;
            text-shadow: 0 0 10px rgba(56,208,108,.5)
        }

        .cte-readout .arrow.y {
            color: #ffd54f;
            text-shadow: 0 0 10px rgba(255,213,79,.5)
        }

        .cte-readout .arrow.r {
            color: #ff5d73;
            text-shadow: 0 0 12px rgba(255,93,115,.7)
        }

        .spd-readout {
            margin-left: 12px
        }

        /* Modern chips for top info */
        .chips {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap
        }

        .chip {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            border-radius: 12px;
            background: rgba(255,255,255,.10);
            border: 1px solid rgba(255,255,255,.25);
            box-shadow: 0 8px 18px rgba(0,0,0,.25)
        }
        /* Apply tabular numerals to all chip values */
        .chip .val { font-variant-numeric: tabular-nums; }
        .chip.gps { cursor: pointer; transition: background .2s ease, border-color .2s ease, color .2s ease; }
        .chip.gps-connecting { background: rgba(255,193,7,.28); border-color: rgba(255,193,7,.55); color: #fff3cd; }
        .chip.gps-connected { background: rgba(56,208,108,.28); border-color: rgba(56,208,108,.65); color: #d9ffe7; }
        .chip.gps-error { background: rgba(244,67,54,.28); border-color: rgba(244,67,54,.55); color: #ffe3df; }
        body.theme-day .chip.gps-connecting { color: #6c4a00; }
        body.theme-day .chip.gps-connected { color: #075c2d; }
        body.theme-day .chip.gps-error { color: #7f1d1d; }

            .chip .ico {
                width: 18px;
                height: 18px;
                opacity: .95
            }

            .chip .label {
                opacity: .9;
                font-weight: 700
            }

            .chip .val {
                font-weight: 800;
                margin-left: 4px
            }

        /* Fixed-width numeric readouts to prevent jumpiness */
        .num-fixed-3 { display:inline-block; min-width:3ch; text-align:right; font-variant-numeric:tabular-nums; }
        /* HUD numeric labels: adaptive width with tabular numerals (stop jiggle) */
        #distTxt, #rateTxtBottom, #hdgTxt, #passTxt, #spdTxt, #areaTxtBottom, #widthTxt {
            display: inline-block;
            text-align: right;
            font-variant-numeric: tabular-nums;
            width: auto !important;
            min-width: 0 !important;
        }
        .cte-num-slot { display:inline-block; width:4ch; text-align:center; font-variant-numeric:tabular-nums; }

        /* Keep units from wrapping awkwardly */
        .chip .unit { white-space: nowrap; }

        /* Big speed card */
        .speed-card {
            position: absolute;
            top: 10px;
            right: 12px;
            padding: 6px 10px;
            border-radius: 12px;
            background: rgba(0,0,0,.28);
            border: 1px solid rgba(255,255,255,.25);
            box-shadow: 0 10px 20px rgba(0,0,0,.35)
        }

        @media (max-width:900px) {
            .speed-card .num {
                font-size: 24px
            }
        }
        /* === Floating main menu toggle (hamburger) === */
        .menu-toggle {
            position: absolute;
            left: 14px;
            top: 12px;
            width: 58px;
            height: 58px;
            border-radius: 9999px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,.12);
            color: #fff;
            border: 1px solid rgba(255,255,255,.35);
            box-shadow: 0 12px 24px rgba(0,0,0,.35);
            cursor: pointer;
            user-select: none;
            z-index: 9;
            touch-action: manipulation
        }

            .menu-toggle .icon {
                width: 26px;
                height: 26px;
                opacity: .95
            }

            .menu-toggle.on {
                background: #4f7cff;
                box-shadow: 0 0 0 4px rgba(79,124,255,.22), 0 16px 28px rgba(0,0,0,.45)
            }

        @media (max-width:700px) {
            .menu-toggle {
                width: 52px;
                height: 52px;
                left: 10px;
                top: 10px
            }

                .menu-toggle .icon {
                    width: 22px;
                    height: 22px
                }
        }
        /* Show/hide the two settings groups via the hamburger button */
        .controls .group {
            display: none
        }

        body.menus-open .controls .group {
            display: flex
        }
        /* Simulator UI toggle */
        body.sim-off .steer-controls {
            display: none !important
        }

        body.sim-off .hint {
            display: none !important
        }
        /* ---- Controls layout fix: keep arrows above taskbar & perfectly centered ---- */
        :root {
            --steer-bottom: 96px
        }

        .steer-controls {
            bottom: var(--steer-bottom);
            gap: 12px;
            justify-items: center;
            z-index: 8
        }

        @media (max-height:620px) {
            :root {
                --steer-bottom: 100px
            }
        }

        @media (max-height:520px) {
            :root {
                --steer-bottom: 112px
            }
        }

        @media (max-height:460px) {
            :root {
                --steer-bottom: 120px
            }
        }
  </style>
 </head>
 <body>
  <!-- Floating menu button (gear) -->
  <button aria-label="Meniu" class="menu-toggle" id="menuToggle">
   <svg class="icon" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="1" stroke-linejoin="miter" stroke-linecap="butt" fill-rule="evenodd" clip-rule="evenodd" aria-hidden="true">
  <path d="M 22.50,12.00 L 19.73,14.07 L 21.09,17.25 L 17.66,17.66 L 17.25,21.09 L 14.07,19.73 L 12.00,22.50 L 9.93,19.73 L 6.75,21.09 L 6.34,17.66 L 2.91,17.25 L 4.27,14.07 L 1.50,12.00 L 4.27,9.93 L 2.91,6.75 L 6.34,6.34 L 6.75,2.91 L 9.93,4.27 L 12.00,1.50 L 14.07,4.27 L 17.25,2.91 L 17.66,6.34 L 21.09,6.75 L 19.73,9.93 Z M 12,12 m -3,0 a 3,3 0 1,0 6,0 a 3,3 0 1,0 -6,0"/>
</svg>
  </button>
  <div class="hud">
   <div class="stats-row">
    <div class="chips">
     <div class="chip">
      <svg class="ico" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24">
       <circle cx="12" cy="12" r="9"></circle>
       <path d="M14.5 9.5L10 14l4.5-4.5Z"></path>
      </svg>
      <span class="label">Kryptis</span>
      <span class="val" id="hdgTxt">0°</span>
     </div>
     <div class="chip gps gps-error" id="gpsChip" title="Pakeisti NodeMCU adresa">
      <svg class="ico" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
       <circle cx="12" cy="12" r="9"></circle>
       <path d="M12 3v3M12 18v3M3 12h3M18 12h3"></path>
       <circle cx="12" cy="12" r="3"></circle>
      </svg>
      <span class="label">GPS</span>
      <span class="val" id="gpsStatusText">Atsijunge</span>
     </div>
     <div class="chip">
      <svg class="ico" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24">
       <path d="M3 17h18"></path>
       <path d="M3 17l3-3M3 17l3 3"></path>
       <path d="M21 17l-3-3M21 17l-3 3"></path>
      </svg>
      <span class="label">Atstumas AB</span>
      <span class="val" id="distTxt">—</span>
     </div>
     <div class="chip">
      <svg class="ico" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24">
       <path d="M4 12H20"></path>
       <path d="M4 12l3-3M4 12l3 3"></path>
       <path d="M20 12l-3-3M20 12l-3 3"></path>
      </svg>
      <span class="label">Padargo plotis</span>
      <span class="val" id="widthTxt">0.00 m</span>
     </div>
    </div>
   </div>
   <!-- LED BAR (moved inside HUD, below chips) -->
   <div class="ledbar-wrap">
    <div class="ledbar" id="ledbar">
     <div class="ledstrip left" id="ledLeft">
     </div>
      <div class="cte-block">
       <div class="cte-readout">
        <span class="num" id="spdTxt">0.0 km/h</span>
       </div>
      <div class="cte-readout">
       <span class="arrow" id="cteLeftArrow">
        ◄
       </span>
        <span class="num"><span id="cteNum" class="cte-num-slot">0</span> <span class="unit">cm</span></span>
       <span class="arrow" id="cteRightArrow">
        ►
       </span>
      </div>
     </div>
     <div class="ledstrip right" id="ledRight">
     </div>
    </div>
   </div>
   <div class="controls">
    <button class="btn toggle" id="btnImpl">
     Padargas: IŠJUNGTA (Tarpas)
    </button>
    <!-- Gairės (collapsible) -->
    <div class="group">
     <button class="btn ghost group-toggle" id="btnGuideSettings">
      Gairės ▾
     </button>
     <div class="group-body" hidden="" id="panelGuide">
      <button class="btn ghost" id="btnSetAB">
       Nustatyti AB (A + kryptis)
      </button>
     </div>
    </div>
    <!-- Padargo nustatymai (collapsible) -->
    <div class="group">
     <button class="btn ghost group-toggle" id="btnImplSettings">
      <svg class="ico" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <path d="M4 8H20"/>
        <path d="M6 10v2M10 10v2M14 10v2M18 10v2"/>
      </svg>
      <svg class="ico" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <path d="M4 8H20"/>
        <path d="M6 10v2M10 10v2M14 10v2M18 10v2"/>
      </svg>
      Padargas ▾
     </button>
     <div class="group-body" hidden="" id="panelImpl">
      <label class="stat">
       Darbinis plotis
       <div class="num-spin">
        <button type="button" class="btn ghost spin" id="btnPassWidthMinus">-</button>
        <input id="passWidth" step="0.01" type="number" value="24"/>
        <button type="button" class="btn ghost spin" id="btnPassWidthPlus">+</button>
        <span>m</span>
       </div>
      </label>
     <label class="stat">
      Sukabos atstumas
      <div class="num-spin">
       <button type="button" class="btn ghost spin" id="btnHitchMinus">-</button>
       <input id="hitchOffset" step="0.01" type="number" value="4"/>
       <button type="button" class="btn ghost spin" id="btnHitchPlus">+</button>
       <span>m</span>
      </div>
     </label>
      <button class="btn ghost" id="btnImplMode">Padargas: Standus</button>
     </div>
    </div>
    <!-- Žemėlapio meniu (collapsible) -->
    <div class="group">
     <button class="btn ghost group-toggle" id="btnMapSettings">
      <svg class="ico" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <path d="M3 6l6-2 6 2 6-2v14l-6 2-6-2-6 2z"/>
        <path d="M9 4v16M15 6v16"/>
      </svg>
      <svg class="ico" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <path d="M3 6l6-2 6 2 6-2v14l-6 2-6-2-6 2z"/>
        <path d="M9 4v16M15 6v16"/>
      </svg>
      Žemėlapis ▾
     </button>
     <div class="group-body" hidden="" id="panelMap">
      <button class="btn toggle" id="btnFollow">
       Sekimas
      </button>
      <button class="btn toggle" id="btnRotate">
       Sukimas
      </button>
       
      <button class="btn ghost" id="btnClearTrail">
       Išvalyti padengimą
      </button>
      
      <button class="btn ghost toggle" id="btnLowPower">
       Paprastas rėžimas
      </button>
      <button class="btn ghost toggle" id="btnSimToggle">
       Simuliatorius
      </button>
      
      </div>
    </div>
   </div>
  </div>
  <!-- Floating Zoom controls (top-right) -->
  <div class="zoom-stack">
    <div class="zoom-group">
      <span class="zoom-label">Priartinti</span>
      <button class="zoom-btn" id="btnZoomIn" aria-label="Priartinti">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <circle cx="11" cy="11" r="7"></circle>
          <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
          <line x1="11" y1="8" x2="11" y2="14"></line>
          <line x1="8" y1="11" x2="14" y2="11"></line>
        </svg>
      </button>
    </div>
    <div class="zoom-group">
      <span class="zoom-label">Atitolinti</span>
      <button class="zoom-btn" id="btnZoomOut" aria-label="Atitolinti">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <circle cx="11" cy="11" r="7"></circle>
          <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
          <line x1="8" y1="11" x2="14" y2="11"></line>
        </svg>
      </button>
    </div>
    <!-- New/Reset floating button with caption -->
    <div class="zoom-group">
      <span class="zoom-label">Naujas</span>
      <button class="zoom-btn" id="btnReset" aria-label="Naujas" title="Naujas">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <circle cx="12" cy="12" r="9"></circle>
          <line x1="12" y1="8" x2="12" y2="16"></line>
          <line x1="8" y1="12" x2="16" y2="12"></line>
        </svg>
      </button>
    </div>
  </div>
  <canvas id="map">
   </canvas>
  <div class="hud hud-bottom">
   <div class="chips">
    <div class="chip">
     <svg class="ico" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24">
      <rect x="5" y="5" width="14" height="14" rx="2" ry="2"/>
      <path d="M5 12h14M12 5v14"/>
     </svg>
     <span class="label">Išdirbtas plotas</span>
     <span class="val" id="areaTxtBottom">0.00 ha</span>
    </div>
    <div class="chip">
     <svg class="ico" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24">
      <circle cx="12" cy="12" r="9"/>
     <path d="M12 12l5-2"/>
      <path d="M12 7v5"/>
     </svg>
     <span class="label">Našumas</span>
     <span class="val" id="rateTxtBottom">0 Ha/Val.</span>
    </div>
    <div class="chip">
     <svg class="ico" fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2" viewBox="0 0 24 24">
      <line x1="4" x2="12" y1="18" y2="10"></line>
      <line x1="8" x2="16" y1="18" y2="10"></line>
      <line x1="12" x2="20" y1="18" y2="10"></line>
     </svg>
     <span class="label">Pravažiavimas</span>
     <span class="val" id="passTxt">0</span>
    </div>
    <div class="chip">
     <svg class="ico" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24">
      <circle cx="7" cy="12" r="2"></circle>
      <circle cx="17" cy="12" r="2"></circle>
      <line x1="9" x2="15" y1="12" y2="12"></line>
      <polyline points="14,10 15,12 14,14"></polyline>
      <polyline points="10,10 9,12 10,14"></polyline>
     </svg>
     <span class="label">AB</span>
     <span class="val" id="abTxt">Nėra</span>
    </div>
   </div>
  </div>
   <div class="hint">
    <b>
     Valdymas
    </b>
    <br/>
    ↑ pagreitinti, ↓ stabdyti/atgal, ←/→ sukti
    <br/>
    Tarpas = Padargas ON/OFF | + / − = Priartinti/Atitolinti | Pelės ratukas = mastelis | Gestas žnyplėmis (pinch) = mastelis
    <br/>
    F = Sekimas ON/OFF | R = Sukimas ON/OFF | Dvigubas spust. = centruoti ir įjungti sekimą
    <br/>
    S = Nustatyti AB (čia+kryptis), A/B = Pažymėti A/B, N = Sukurti AB iš A→B
   </div>
   <!-- On-screen driving controls -->
   <div class="steer-controls">
    <button aria-label="Važiuoti pirmyn" class="steer-btn" id="btnFwd">
     ▲
    </button>
    <button aria-label="Sukti kairėn" class="steer-btn" id="btnSteerLeft">
     ◀
    </button>
    <button aria-label="Sukti dešinėn" class="steer-btn" id="btnSteerRight">
     ▶
    </button>
    <button aria-label="Važiuoti atgal" class="steer-btn" id="btnBack">
     ▼
    </button>
   </div>
   <!-- Floating A/B action button (single) -->
   <button class="fab left" id="fabAB">
    Pažymėti A
   </button>
      <!-- Floating Implement ON/OFF toggle (right side) -->
   <button id="applyToggle" class="apply-toggle on" aria-pressed="true" title="Padargas įjungtas (Tarpas)" aria-label="Padargas">
        <!-- Implement icon: tractor triangle towing sprayer boom -->
    <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
  <path d="M12 5 L16 13 H8 Z" fill="#ffd600" stroke="#000" stroke-width="1"/>
  <line x1="12" y1="13" x2="12" y2="17" />
  <line x1="5" y1="17" x2="19" y2="17" />
  <line x1="9.67" y1="16" x2="9.67" y2="18" />
  <line x1="14.33" y1="16" x2="14.33" y2="18" />
  <circle cx="7" cy="18.5" r="0.8" />
  <circle cx="9.5" cy="18.5" r="0.8" />
  <circle cx="12" cy="18.5" r="0.8" />
  <circle cx="14.5" cy="18.5" r="0.8" />
  <circle cx="17" cy="18.5" r="0.8" />
  <rect class="trail" x="5" y="19" width="14" height="3" rx="1.2" ry="1.2"/>
  <line class="off-strike" x1="4" y1="4" x2="20" y2="20"/>
</svg>
   </button>
   <script>
    // === v22.3 — Stable core + big CTE readout + floating Implement toggle ===
            (function () {
                // ----- Canvas -----
                var canvas = document.getElementById('map');
                var ctx = canvas.getContext('2d');
                var W, H; function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; } window.addEventListener('resize', resize); resize();

                // IE detect for RT low-power
                var isIE = !!window.MSInputMethodContext && !!document.documentMode;
                var LOWPOWER = false;

                // ----- Camera -----
                var basePxPerM = 12, zoom = 1; function pxPerM() { return basePxPerM * zoom; }
                var camX = 0, camY = 0, camRot = 0; var follow = true, rotateOn = true;
                function updateFollowBtn() { var b = document.getElementById('btnFollow'); if (b) { b.textContent = 'Sekimas ' + (follow ? '' : '') + ''; b.classList.toggle('on', follow); } }
                function updateRotateBtn() { var b = document.getElementById('btnRotate'); if (b) { b.textContent = 'Sukimas ' + (rotateOn ? '' : '') + ''; b.classList.toggle('on', rotateOn); } }
                function updateLowPowerBtn() { var b = document.getElementById('btnLowPower'); if (b) { b.textContent = 'Supaprastintas' + (LOWPOWER ? '' : ''); b.classList.toggle('on', LOWPOWER); } }

                function worldToScreen(wx, wy) { var ppm = pxPerM(), c = Math.cos(camRot), s = Math.sin(camRot); var dx = wx - camX, dy = wy - camY; var rx = dx * c + dy * s, ry = -dx * s + dy * c; return { x: rx * ppm + W / 2, y: ry * ppm + H / 2 }; }
                function screenToWorld(sx, sy) { var ppm = pxPerM(), c = Math.cos(camRot), s = Math.sin(camRot); var rx = (sx - W / 2) / ppm, ry = (sy - H / 2) / ppm; var dx = rx * c - ry * s, dy = rx * s + ry * c; return { x: dx + camX, y: dy + camY }; }
                function zoomAtScreenPoint(scale, sx, sy) { var before = screenToWorld(sx, sy); zoom = Math.max(.25, Math.min(4, zoom * scale)); var after = screenToWorld(sx, sy); camX += before.x - after.x; camY += before.y - after.y; }

                // Mouse/touch interaction
                var dragging = false, lastSx = 0, lastSy = 0; canvas.addEventListener('mousedown', function (e) { dragging = true; lastSx = e.clientX; lastSy = e.clientY; if (follow) { follow = false; updateFollowBtn(); } });
                window.addEventListener('mouseup', function () { dragging = false; });
                window.addEventListener('mousemove', function (e) { if (!dragging) return; var dx = e.clientX - lastSx, dy = e.clientY - lastSy; lastSx = e.clientX; lastSy = e.clientY; var m = 1 / pxPerM(); var c = Math.cos(camRot), s = Math.sin(camRot); var wx = (dx * m) * c - (dy * m) * s; var wy = (dx * m) * s + (dy * m) * c; camX -= wx; camY -= wy; });
                canvas.addEventListener('wheel', function (e) { e.preventDefault(); var r = canvas.getBoundingClientRect(); zoomAtScreenPoint(e.deltaY < 0 ? 1.15 : 1 / 1.15, e.clientX - r.left, e.clientY - r.top); }, { passive: false });
                canvas.addEventListener('dblclick', function () { camX = x; camY = y; follow = true; updateFollowBtn(); if (rotateOn) camRot = hdg; });
                // Pinch zoom
                var tState = null; function tdist(a, b) { var dx = a.clientX - b.clientX, dy = a.clientY - b.clientY; return Math.hypot(dx, dy); } function findTouch(list, id) { for (var i = 0; i < list.length; i++) if (list[i].identifier === id) return list[i]; }
                canvas.addEventListener('touchstart', function (e) { if (e.touches.length === 2) { e.preventDefault(); var t1 = e.touches[0], t2 = e.touches[1]; tState = { id1: t1.identifier, id2: t2.identifier, d0: tdist(t1, t2) }; if (follow) { follow = false; updateFollowBtn(); } } }, { passive: false });
                canvas.addEventListener('touchmove', function (e) { if (!tState) return; var t1 = findTouch(e.touches, tState.id1), t2 = findTouch(e.touches, tState.id2); if (!t1 || !t2) { tState = null; return; } e.preventDefault(); var d = tdist(t1, t2); var rect = canvas.getBoundingClientRect(); var midx = (t1.clientX + t2.clientX) / 2 - rect.left; var midy = (t1.clientY + t2.clientY) / 2 - rect.top; zoomAtScreenPoint(d / tState.d0, midx, midy); tState.d0 = d; }, { passive: false });
                canvas.addEventListener('touchend', function () { tState = null; });

                // ----- Simulation state -----
                var x = 0, y = 0, hdg = 0; // 0 rad = up
                var v = 0, steer = 0, maxYawRate = 1.3, accel = 2.2, drag = 0.6, reverseAccel = 3.0, dt = 0.016;
                var cruiseOn = false, cruiseSet = 0, cruiseMax = 10;

                // --- GPS bridge state ---
                var gpsEnabled = false;
                var gpsPose = null;          // latest normalized GPS fix (lat/lon heading, speed)
                var gpsOrigin = null;        // anchor lat/lon for local projection
                var gpsLastFixMs = 0;

                function notifyGpsState(detail) {
                    try {
                        document.dispatchEvent(new CustomEvent('agro:gps-state', { detail: detail || null }));
                    } catch (_) {}
                }

                function setGpsEnabled(flag) {
                    gpsEnabled = !!flag;
                    notifyGpsState({ type: 'toggle', enabled: gpsEnabled });
                }

                function resetGpsOrigin() {
                    gpsOrigin = null;
                    notifyGpsState({ type: 'origin-reset' });
                }

                function ensureGpsOrigin(lat, lon) {
                    if (!gpsOrigin && isFinite(lat) && isFinite(lon)) {
                        gpsOrigin = { lat: lat, lon: lon };
                        notifyGpsState({ type: 'origin-set', origin: gpsOrigin });
                    }
                }

                function latLonToLocal(lat, lon) {
                    if (!gpsOrigin) return { x: x, y: y };
                    var lat0 = gpsOrigin.lat * Math.PI / 180;
                    var dLat = (lat - gpsOrigin.lat) * Math.PI / 180;
                    var dLon = (lon - gpsOrigin.lon) * Math.PI / 180;
                    var earth = 6378137;
                    var localX = earth * dLon * Math.cos(lat0);
                    var localY = -earth * dLat;
                    return { x: localX, y: localY };
                }

                function applyGpsPose() {
                    if (!gpsPose) return false;
                    if (!isFinite(gpsPose.lat) || !isFinite(gpsPose.lon)) return false;
                    ensureGpsOrigin(gpsPose.lat, gpsPose.lon);
                    if (!gpsOrigin) return false;
                    var local = latLonToLocal(gpsPose.lat, gpsPose.lon);
                    x = local.x;
                    y = local.y;
                    if (typeof gpsPose.hdg === 'number' && isFinite(gpsPose.hdg)) {
                        hdg = gpsPose.hdg;
                    }
                    if (typeof gpsPose.speed === 'number' && isFinite(gpsPose.speed)) {
                        v = gpsPose.speed;
                    }
                    gpsLastFixMs = performance.now();
                    return true;
                }

                function normalizeGpsSample(sample) {
                    if (!sample || typeof sample.lat !== 'number' || typeof sample.lon !== 'number') return;
                    var headingRad = null;
                    if (typeof sample.heading_rad === 'number') {
                        headingRad = sample.heading_rad;
                    } else {
                        var headingDeg = null;
                        if (typeof sample.heading_deg === 'number') headingDeg = sample.heading_deg;
                        else if (typeof sample.course_deg === 'number') headingDeg = sample.course_deg;
                        else if (typeof sample.heading === 'number') headingDeg = sample.heading;
                        if (headingDeg !== null) headingRad = headingDeg * Math.PI / 180;
                    }
                    var speedMps = null;
                    if (typeof sample.speed_mps === 'number') speedMps = sample.speed_mps;
                    else if (typeof sample.speed_kph === 'number') speedMps = sample.speed_kph / 3.6;
                    else if (typeof sample.speed_knots === 'number') speedMps = sample.speed_knots * 0.514444;
                    else if (typeof sample.speed === 'number') speedMps = sample.speed;
                    gpsPose = {
                        lat: sample.lat,
                        lon: sample.lon,
                        hdg: headingRad,
                        speed: speedMps,
                        raw: sample
                    };
                    notifyGpsState({ type: 'fix', pose: gpsPose });
                }
                function adjustCruise(delta) { cruiseSet = Math.max(0, Math.min(cruiseMax, cruiseSet + delta)); cruiseOn = cruiseSet > 0; }

                // Implement & coverage (default ON)
                // Note: hitchOffset is measured from tractor tail (base of triangle), not center
                var implement = true, hitchOffset = 4.0, passWidth = 24.0, tractorTailBack = 4.8; // meters from center to triangle tail
                var implementMode = 'axle'; // default to 'Ant ašies' (trailer-like)
                var implHdg = 0;             // implement heading (used in 'axle' mode)
                // Trailer-like articulation tuning (axle mode)
                var implMaxRate   = 1.4;     // max articulation rate (rad/s)
                var coverageQuads = [], lastBar = null, coverageCap = Infinity;
                var totalAreaM2 = 0; // accumulated worked area in m^2
                // Preferences helpers
                function savePrefs(){ try {
                    localStorage.setItem('impl.passWidth', String(passWidth));
                    localStorage.setItem('impl.hitchOffset', String(hitchOffset));
                    localStorage.setItem('impl.mode', implementMode);
                } catch(_){} }
                function loadPrefs(){ try {
                    var w = parseFloat(localStorage.getItem('impl.passWidth'));
                    if (isFinite(w) && w > 0.1) passWidth = w;
                    var h = parseFloat(localStorage.getItem('impl.hitchOffset'));
                    if (isFinite(h) && h >= 0) hitchOffset = h;
                    var m = localStorage.getItem('impl.mode');
                    if (m === 'rigid' || m === 'axle') implementMode = m;
                } catch(_){}
                // reflect into inputs/buttons if present
                var pw = document.getElementById('passWidth'); if (pw) pw.value = (''+passWidth).replace(/\.00$/, '');
                var ho = document.getElementById('hitchOffset'); if (ho) ho.value = (''+hitchOffset).replace(/\.00$/, '');
                if (typeof updateImplModeBtn === 'function') updateImplModeBtn();
                }
                function updateImplementUI() { var b = document.getElementById('btnImpl'); if (b) { b.textContent = 'Padargas: ' + (implement ? '' : '') + ''; b.classList.toggle('on', implement); } var flo = document.getElementById('applyToggle'); if (flo) { flo.classList.toggle('on', implement); flo.classList.toggle('off', !implement); flo.setAttribute('aria-pressed', implement ? 'true' : 'false'); flo.title = 'Padargas ' + (implement ? '' : '') + ''; } }
                function toggleImplement() { implement = !implement; updateImplementUI(); }

                // Simulator UI toggle (show/hide on-screen arrows and hint)
                var simulatorOn = true;
                function updateSimBtn() { var b = document.getElementById('btnSimToggle'); if (b) { b.textContent = 'Simuliatorius ' + (simulatorOn ? '' : ''); b.classList.toggle('on', simulatorOn); } }
                function setSimulatorOn(v) { simulatorOn = !!v; document.body.classList.toggle('sim-off', !simulatorOn); updateSimBtn(); }

                // A/B + single FAB flow
                var AB = null, markA = null, markB = null;
                var abDistanceMeters = null; // last confirmed A→B distance
                var minDistForB = 15;              // minimum 15 m between A and B
                var abStage = 'A', bEligible = false; // 'A' | 'A_wait' | 'B'
                var nearestPass = 0, activePass = 0;
                var abJustCreated = false;         // makes the FAB red right after saving B

                function refreshABStatus() {
                    var e = document.getElementById('abTxt'); if (!e) return;
                    var t = 'Nenustatyta'; if (AB) t = 'Nustatyta'; else if (markA) t = 'A';
                    e.textContent = t;
                }

                function setABHere() {
                    // One-tap AB from current pose & heading
                    markA = null; markB = null; bEligible = false; abStage = 'A'; abJustCreated = false; abDistanceMeters = null;
                    updateABFab();
                    AB = { x0: x, y0: y, hdg: hdg };
                    activePass = Math.round(cteForPose(x, y) / passWidth);
                    refreshABStatus();
                }

                function startMarkA() {
                    // Start A->B capture
                    AB = null; activePass = 0; nearestPass = 0; abDistanceMeters = null;
                    markB = null; markA = { x: x, y: y };
                    bEligible = false; abStage = 'A_wait';
                    abJustCreated = false; // back to normal blue while waiting for B
                    refreshABStatus();
                    updateABFab();
                }

                function tryMarkB() {
                    if (!markA) return;
                    var d = Math.hypot(x - markA.x, y - markA.y);
                    if (d < minDistForB) return; // not far enough yet

                    markB = { x: x, y: y };
                    // store distance before building AB and clearing marks
                    abDistanceMeters = Math.hypot(markB.x - markA.x, markB.y - markA.y);
                    buildABFromAB();

                    // reset markers & stage
                    markA = null; markB = null; bEligible = false;
                    abStage = 'A';
                    abJustCreated = true; // next time show Pažymėti A in RED
                    refreshABStatus();
                    updateABFab();
                }

                function updateABFab() {
                    var fab = document.getElementById('fabAB');
                    if (!fab) return;
                    if (abStage === 'B') {
                        // Ready to mark B -> green
                        fab.textContent = 'Pažymėti B?';
                        fab.classList.add('fab-b');
                        fab.classList.remove('fab-a-attn');
                    } else {
                        // A or A_wait -> always blue; after saving B, text becomes "Pažymėti naują A"
                        fab.classList.remove('fab-b');
                        fab.classList.remove('fab-a-attn');
                        fab.textContent = abJustCreated ? 'Pažymėti naują A' : 'Pažymėti A';
                    }
                    // Override to avoid clobbering button content (keep icons)
                    setGroupsExpanded = function(open) {
                        var pairs = [
                            ['btnGuideSettings','panelGuide'],
                            ['btnImplSettings','panelImpl'],
                            ['btnMapSettings','panelMap']
                        ];
                        for (var i = 0; i < pairs.length; i++) {
                            var b = document.getElementById(pairs[i][0]);
                            var p = document.getElementById(pairs[i][1]);
                            if (!p) continue;
                            if (open) { p.removeAttribute('hidden'); if (b) b.classList.add('open'); }
                            else { p.setAttribute('hidden',''); if (b) b.classList.remove('open'); }
                        }
                    }
                }

                function buildABFromAB() {
                    if (!markA || !markB) return;
                    var dx = markB.x - markA.x, dy = markB.y - markA.y;
                    var h = Math.atan2(dx, -dy); // heading along A->B
                    AB = { x0: markA.x, y0: markA.y, hdg: h };
                    activePass = Math.round(cteForPose(x, y) / passWidth);
                    refreshABStatus();
                }

                function cteForPose(px, py) {
                    if (!AB) return 0;
                    var nx = Math.cos(AB.hdg), ny = Math.sin(AB.hdg);
                    var ex = px - AB.x0, ey = py - AB.y0;
                    return ex * nx + ey * ny;
                }

                function cteRelativeToActivePass(px, py) {
                    if (!AB) return 0;
                    var raw = cteForPose(px, py);
                    nearestPass = Math.round(raw / passWidth);
                    if (Math.abs(raw - activePass * passWidth) > passWidth / 2) activePass = nearestPass;
                    return raw - activePass * passWidth;
                }

                // LED bar
                var ledsLeft = document.getElementById('ledLeft'), ledsRight = document.getElementById('ledRight'); var LED_COUNT = 16;
                function buildLeds() { if (!ledsLeft || !ledsRight) return; ledsLeft.innerHTML = ''; ledsRight.innerHTML = ''; LED_COUNT = LOWPOWER ? 10 : 16; for (var i = 0; i < LED_COUNT; i++) { var a = document.createElement('div'); a.className = 'led'; ledsLeft.appendChild(a); var b = document.createElement('div'); b.className = 'led'; ledsRight.appendChild(b); } }
                function updateLedBar(cte) {
                    if (!ledsLeft || !ledsRight) return;

                    // Determine heading-relative guidance sign.
                    // When driving opposite the AB heading (>90°), invert the steer indication.
                    var headingSign = 1;
                    if (AB) {
                        var d = hdg - AB.hdg;               // angle difference
                        d = (d + Math.PI) % (2 * Math.PI) - Math.PI; // normalize to (-π, π]
                        headingSign = (Math.abs(d) <= Math.PI / 2) ? 1 : -1;
                    }
                    var guide = cte * headingSign; // use this for which-way-to-steer logic

                    // --- side LEDs --- (intensity based on absolute error)
                    var m = Math.abs(cte);
                    var perLed = 0.15; // 15 cm per LED
                    var lit = Math.min(LED_COUNT, Math.floor(m / perLed));

                    for (var k = 0; k < LED_COUNT; k++) {
                        if (ledsLeft.children[k]) ledsLeft.children[k].className = 'led';
                        if (ledsRight.children[k]) ledsRight.children[k].className = 'led';
                    }

                    if (lit > 0) {
                        // Light the side you should steer TOWARD (opposite of error, heading-aware)
                        var side = (guide >= 0) ? ledsLeft.children : ledsRight.children;
                        for (var n = 0; n < lit; n++) {
                            var el = side[n]; if (!el) break;
                            var frac = (n + 1) / LED_COUNT;
                            var cls = (frac < .33) ? 'g' : (frac < .66 ? 'y' : 'r');
                            el.className = 'led on ' + cls;
                        }
                    }

                    // --- center readout + colored arrows ---
                    var num = document.getElementById('cteNum');
                    if (num) num.textContent = padFig(Math.round(m * 100), 4);

                    var la = document.getElementById('cteLeftArrow');
                    var ra = document.getElementById('cteRightArrow');
                    var thr = 0.02; // 2 cm = centered
                    if (la && ra) {
                        // reset base classes
                        la.className = 'arrow';
                        ra.className = 'arrow';
                        if (m > thr) {
                            var sev = (m >= 0.25) ? 'r' : (m >= 0.10 ? 'y' : 'g');
                            // Opposite-of-error + heading-aware: if guide < 0 -> steer right; else steer left
                            if (guide < 0) ra.className = 'arrow active ' + sev; else la.className = 'arrow active ' + sev;
                        }
                    }
                }

                // Keyboard
                var keys = {};
                window.addEventListener('keydown', function (e) { keys[e.key] = true; if (e.key === ' ') { e.preventDefault(); toggleImplement(); } if (e.key === 'f' || e.key === 'F') { follow = !follow; updateFollowBtn(); } if (e.key === 'r' || e.key === 'R') { rotateOn = !rotateOn; updateRotateBtn(); } if (e.key === 's' || e.key === 'S') { setABHere(); } if (e.key === 'n' || e.key === 'N') { buildABFromAB(); } if (e.key === '+' || e.key === '=') zoomAtScreenPoint(1.15, W / 2, H / 2); if (e.key === '-' || e.key === '_') zoomAtScreenPoint(1 / 1.15, W / 2, H / 2); });
                window.addEventListener('keyup', function (e) { keys[e.key] = false; });

                // Buttons
                var $ = function (id) { return document.getElementById(id) };
                // Figure-space padding for stable-width numbers without fixed containers
                var FIG = '\u2007';
                function padFig(str, width){ str = String(str); while (str.length < width) str = FIG + str; return str; }
                function updateStatText(ids, text) {
                    for (var i = 0; i < ids.length; i++) {
                        var el = document.getElementById(ids[i]);
                        if (el) el.textContent = text;
                    }
                }
                var areaStatIds = ['areaTxtBottom'];
                var rateStatIds = ['rateTxtBottom'];
                if ($('btnImpl')) $('btnImpl').onclick = toggleImplement;
                if ($('btnSetAB')) $('btnSetAB').onclick = setABHere;
                // removed btnClearTrail UI/button; clearing action disabled
                if ($('btnReset')) $('btnReset').onclick = function () {
                    // Reset pose and camera
                    x = 0; y = 0; hdg = 0; v = 0; steer = 0;
                    camX = x; camY = y; camRot = rotateOn ? hdg : 0;
                    // Instantly align implement with tractor heading
                    implHdg = hdg;

                    // Clear coverage/application and area counters
                    coverageQuads.length = 0; lastBar = null; totalAreaM2 = 0;

                    // Remove AB guidance and reset related state/counters
                    AB = null; markA = null; markB = null; abDistanceMeters = null;
                    abStage = 'A'; bEligible = false; abJustCreated = false;
                    activePass = 0; nearestPass = 0;

                    // Update UI readouts immediately
                    var e;
                    updateStatText(areaStatIds, padFig('0.00', 5) + ' ha');
                    updateStatText(rateStatIds, padFig('0', 3) + ' Ha/Val.');
                    if ((e = document.getElementById('distTxt'))) e.textContent = padFig('-', 3) + ' m';
                    if ((e = document.getElementById('passTxt'))) e.textContent = padFig('0', 3);
                    refreshABStatus();
                    if (typeof updateABFab === 'function') updateABFab();
                };
                // Zoom buttons: handle click + touch and also delegate on group container
                (function(){
                    var zin = $('btnZoomIn');
                    if (zin) {
                        var zinHandler = function (e) { if (e) e.preventDefault(); zoomAtScreenPoint(1.15, W / 2, H / 2); };
                        zin.onclick = zinHandler;
                        try { zin.addEventListener('touchstart', zinHandler, { passive: false }); } catch(_) { zin.addEventListener('touchstart', zinHandler); }
                        try { zin.addEventListener('pointerdown', zinHandler); } catch(_) {}
                        if (zin.parentElement) {
                            zin.parentElement.addEventListener('click', function(e){ e.preventDefault(); zinHandler(e); });
                            try { zin.parentElement.addEventListener('touchstart', function(e){ e.preventDefault(); zinHandler(e); }, { passive: false }); } catch(_) { zin.parentElement.addEventListener('touchstart', function(e){ e.preventDefault(); zinHandler(e); }); }
                        }
                    }
                    var zout = $('btnZoomOut');
                    if (zout) {
                        var zoutHandler = function (e) { if (e) e.preventDefault(); zoomAtScreenPoint(1 / 1.15, W / 2, H / 2); };
                        zout.onclick = zoutHandler;
                        try { zout.addEventListener('touchstart', zoutHandler, { passive: false }); } catch(_) { zout.addEventListener('touchstart', zoutHandler); }
                        try { zout.addEventListener('pointerdown', zoutHandler); } catch(_) {}
                        if (zout.parentElement) {
                            zout.parentElement.addEventListener('click', function(e){ e.preventDefault(); zoutHandler(e); });
                            try { zout.parentElement.addEventListener('touchstart', function(e){ e.preventDefault(); zoutHandler(e); }, { passive: false }); } catch(_) { zout.parentElement.addEventListener('touchstart', function(e){ e.preventDefault(); zoutHandler(e); }); }
                        }
                        // Capture-phase fallback: trigger when clicking within button rect even if overlaid
                        try {
                            var captureClick = function(e){
                                var r = zout.getBoundingClientRect();
                                var x = (e.touches && e.touches[0] ? e.touches[0].clientX : e.clientX);
                                var y = (e.touches && e.touches[0] ? e.touches[0].clientY : e.clientY);
                                if (x >= r.left && x <= r.right && y >= r.top && y <= r.bottom) {
                                    e.preventDefault();
                                    zoutHandler(e);
                                }
                            };
                            document.addEventListener('click', captureClick, true);
                            document.addEventListener('pointerdown', captureClick, true);
                            document.addEventListener('touchstart', captureClick, { capture: true, passive: false });
                        } catch(_) {}
                    }
                })();
                if ($('btnFollow')) $('btnFollow').onclick = function () { follow = !follow; updateFollowBtn(); if (follow) { camX = x; camY = y; if (rotateOn) camRot = hdg; } };
                if ($('btnRotate')) $('btnRotate').onclick = function () { rotateOn = !rotateOn; updateRotateBtn(); if (rotateOn && follow) camRot = hdg; };
                if ($('btnLowPower')) $('btnLowPower').onclick = function () { setLowPower(!LOWPOWER); };
                if ($('btnSimToggle')) $('btnSimToggle').onclick = function () { setSimulatorOn(!simulatorOn); };
                if ($('passWidth')) $('passWidth').oninput = function () { passWidth = Math.max(.1, parseFloat(this.value) || 24); savePrefs(); };
                if ($('hitchOffset')) $('hitchOffset').oninput = function () { hitchOffset = Math.max(0, parseFloat(this.value) || 4); savePrefs(); };
                function updateImplModeBtn(){ var b = $('btnImplMode'); if (!b) return; var isAxle = (implementMode==='axle'); b.textContent = 'Padargas: ' + (isAxle ? 'Ant ašies' : 'Standus'); b.classList.toggle('on', isAxle); }
                if ($('btnImplMode')) $('btnImplMode').onclick = function(){ implementMode = (implementMode === 'rigid') ? 'axle' : 'rigid'; implHdg = hdg; updateImplModeBtn(); savePrefs(); };

                // Spin buttons (±0.5 m)
                function adjustNumberInput(id, delta, min, max) {
                    var inp = $(id); if (!inp) return;
                    var raw = ('' + inp.value).replace(',', '.');
                    var val = parseFloat(raw); if (isNaN(val)) val = 0;
                    val = Math.max(min, Math.min(max, val + delta));
                    // keep two decimals
                    inp.value = val.toFixed(2).replace(/\.00$/, '');
                    inp.dispatchEvent(new Event('input'));
                }
                var bwm = $('btnPassWidthMinus'); if (bwm) bwm.onclick = function(){ adjustNumberInput('passWidth', -0.5, 0.1, 100); };
                var bwp = $('btnPassWidthPlus'); if (bwp) bwp.onclick = function(){ adjustNumberInput('passWidth', +0.5, 0.1, 100); };
                var bhm = $('btnHitchMinus'); if (bhm) bhm.onclick = function(){ adjustNumberInput('hitchOffset', -0.5, 0.0, 50); };
                var bhp = $('btnHitchPlus'); if (bhp) bhp.onclick = function(){ adjustNumberInput('hitchOffset', +0.5, 0.0, 50); };

                // Override: fine 1 cm steps, hold to accelerate to 10 cm
                (function(){
                    function bindSpinHold(btnId, inputId, sign, min, max){
                        var btn = $(btnId); if (!btn) return;
                        var holdTimer = null, accelTimer = null, step = 0.01; // 1 cm
                        var tick = function(){ adjustNumberInput(inputId, sign * step, min, max); };
                        var stop = function(){ if (holdTimer) { clearInterval(holdTimer); holdTimer = null; } if (accelTimer) { clearTimeout(accelTimer); accelTimer = null; } };
                        var start = function(e){ if (e) e.preventDefault(); step = 0.01; tick(); stop(); holdTimer = setInterval(tick, 100); accelTimer = setTimeout(function(){ step = 0.10; }, 700); };
                        btn.onclick = null; // disable old single-click handler
                        btn.addEventListener('mousedown', start);
                        try { btn.addEventListener('touchstart', start, { passive: false }); } catch(_) { btn.addEventListener('touchstart', start); }
                        ['mouseup','mouseleave','touchend','touchcancel'].forEach(function(ev){ btn.addEventListener(ev, stop); });
                        btn.addEventListener('click', function(e){ if (e) e.preventDefault(); });
                    }
                    bindSpinHold('btnPassWidthMinus', 'passWidth', -1, 0.1, 100);
                    bindSpinHold('btnPassWidthPlus',  'passWidth', +1, 0.1, 100);
                    bindSpinHold('btnHitchMinus',     'hitchOffset', -1, 0.0, 50);
                    bindSpinHold('btnHitchPlus',      'hitchOffset', +1, 0.0, 50);
                })();

                // Collapsible panels
                (function () {
                    function togglePanel(btn, panel) { var open = !panel.hasAttribute('hidden'); if (open) { panel.setAttribute('hidden', ''); if (btn) btn.textContent = btn.textContent.replace('▴', '▾'); } else { panel.removeAttribute('hidden'); if (btn) btn.textContent = btn.textContent.replace('▾', '▴'); } }
                    var b1 = $('btnImplSettings'), p1 = $('panelImpl'); var b2 = $('btnMapSettings'), p2 = $('panelMap'); if (p1) p1.hidden = true; if (p2) p2.hidden = true; if (b1 && p1) b1.addEventListener('click', function () { togglePanel(b1, p1); }); if (b2 && p2) b2.addEventListener('click', function () { togglePanel(b2, p2); });
                    var b3 = $('btnGuideSettings'), p3 = $('panelGuide'); if (p3) p3.hidden = true; if (b3 && p3) b3.addEventListener('click', function () { togglePanel(b3, p3); });
                    // normalize togglePanel not to clobber button content (keep inline SVG icons)
                    togglePanel = function (btn, panel) {
                        var open = !panel.hasAttribute('hidden');
                        if (open) { panel.setAttribute('hidden',''); }
                        else { panel.removeAttribute('hidden'); }
                        if (btn) btn.classList.toggle('open', !open);
                    };
                })();

                // Floating Implement toggle: bind after DOM is fully parsed
                document.addEventListener('DOMContentLoaded', function () {
                    // Load user preferences for implement
                    loadPrefs();
                    // Floating implement toggle
                    var t = document.getElementById('applyToggle');
                    if (t) {
                        t.addEventListener('click', function (e) { e.preventDefault(); toggleImplement(); });
                    }
                    // Menu toggle
                    var mbtn = document.getElementById('menuToggle');
                    function setGroupsExpanded(open) {
                        var pairs = [
                            ['btnGuideSettings','panelGuide'],
                            ['btnImplSettings','panelImpl'],
                            ['btnMapSettings','panelMap']
                        ];
                        for (var i = 0; i < pairs.length; i++) {
                            var b = document.getElementById(pairs[i][0]);
                            var p = document.getElementById(pairs[i][1]);
                            if (!p) continue;
                            if (open) {
                                p.removeAttribute('hidden');
                                if (b) b.textContent = b.textContent.replace('▾', '▴');
                            } else {
                                p.setAttribute('hidden','');
                                if (b) b.textContent = b.textContent.replace('▴', '▾');
                            }
                        }
                    }
                    // Ensure collapsed and menu closed on load
                    document.body.classList.remove('menus-open');
                    if (mbtn) mbtn.classList.remove('on');
                    setGroupsExpanded(false);
                    if (mbtn) {
                        mbtn.addEventListener('click', function (e) {
                            e.preventDefault();
                            var nowOpen = !document.body.classList.contains('menus-open');
                            document.body.classList.toggle('menus-open');
                            mbtn.classList.toggle('on');
                            // Keep all groups collapsed; user opens individually
                            setGroupsExpanded(false);
                        });
                    }

                    // Single FAB for A/B marking
                    var fab = document.getElementById('fabAB');
                    if (fab) {
                        fab.addEventListener('click', function (e) {
                            e.preventDefault();
                            if (abStage === 'B') { tryMarkB(); }
                            else { startMarkA(); }
                        });
                    }
                    // sync UI
                    updateImplementUI();
                    updateImplModeBtn();
                    updateABFab();
                    refreshABStatus();
                    // ensure correct visibility state (show hint/controls when sim is ON)
                    setSimulatorOn(simulatorOn);
                });

                // On‑screen driving controls (pointer)
                function bindHold(btnId, key) { var btn = $(btnId); if (!btn) return; var active = false, pid = null; function up() { if (!active) return; keys[key] = false; btn.classList.remove('on'); active = false; if (pid != null && btn.releasePointerCapture) { try { btn.releasePointerCapture(pid); } catch (_) { } } pid = null; } btn.addEventListener('pointerdown', function (e) { e.preventDefault(); keys[key] = true; btn.classList.add('on'); active = true; if (btn.setPointerCapture && e.pointerId != null) { pid = e.pointerId; btn.setPointerCapture(pid); } }); btn.addEventListener('pointerup', up); btn.addEventListener('pointercancel', up); btn.addEventListener('pointerleave', up); window.addEventListener('pointerup', up); }
                function bindCruiseStep(btnId, delta) { var btn = $(btnId); if (!btn) return; var timer = null; function step() { adjustCruise(delta); btn.classList.add('on'); } btn.addEventListener('pointerdown', function (e) { e.preventDefault(); step(); if (btn.setPointerCapture && e.pointerId != null) btn.setPointerCapture(e.pointerId); timer = setInterval(step, 140); }); function stop() { if (timer) { clearInterval(timer); timer = null; } btn.classList.remove('on'); } btn.addEventListener('pointerup', stop); btn.addEventListener('pointercancel', stop); btn.addEventListener('pointerleave', stop); window.addEventListener('pointerup', stop); }
                bindCruiseStep('btnFwd', +0.5); bindHold('btnSteerLeft', 'ArrowLeft'); bindHold('btnSteerRight', 'ArrowRight'); bindCruiseStep('btnBack', -0.5);

                // --- Keep steer controls above OS taskbar / dock ---
                function autoLiftControls() {
                    var sc = document.querySelector('.steer-controls');
                    if (!sc) return;
                    // reset to base value from CSS var
                    sc.style.bottom = getComputedStyle(document.documentElement).getPropertyValue('--steer-bottom').trim() || '96px';
                    requestAnimationFrame(function () {
                        var r = sc.getBoundingClientRect();
                        var minGap = 16; // pixels from screen bottom
                        var gap = window.innerHeight - r.bottom; // positive when fully visible
                        if (gap < minGap) {
                            var extra = Math.ceil(minGap - gap);
                            sc.style.bottom = 'calc(var(--steer-bottom) + ' + extra + 'px)';
                        }
                    });
                }
                window.addEventListener('resize', autoLiftControls);
                window.addEventListener('orientationchange', autoLiftControls);

                // Low power
                function setLowPower(v) { LOWPOWER = !!v; updateLowPowerBtn(); buildLeds(); coverageCap = LOWPOWER ? 300 : Infinity; }

                // Helpers
                function angleLerp(a, b, t) { var d = ((b - a + Math.PI) % (2 * Math.PI)) - Math.PI; return a + d * t; }
                // Triangle size based on implement width
                function triDimsForWidth(w) {
                    var L, W; // length and base width (meters)
                    if (w <= 8) { L = 10; W = 8; }
                    else if (w <= 24) { L = 12; W = 10; }
                    else { L = 16; W = 14; }
                    return { L: L, W: W, tail: L * 0.4 };
                }
                function currentImplementBar() {
                    var half = passWidth / 2;
                    // tractor tail location (base of triangle)
                    var tx = x - Math.sin(hdg) * tractorTailBack;
                    var ty = y - (-Math.cos(hdg)) * tractorTailBack;
                    // implement heading (rigid uses tractor heading)
                    var head = (implementMode === 'axle') ? implHdg : hdg;
                    var nx = Math.cos(head), ny = Math.sin(head);
                    // hitch point lies straight behind the tail along implement heading
                    var hx2 = Math.sin(head), hy2 = -Math.cos(head);
                    var hitchX = tx - hx2 * hitchOffset, hitchY = ty - hy2 * hitchOffset;
                    return { L: { x: hitchX - nx * half, y: hitchY - ny * half }, R: { x: hitchX + nx * half, y: hitchY + ny * half }, H: { x: hitchX, y: hitchY }, T: { x: tx, y: ty }, head: head }
                }

                // Update
                var frameTick = 0;
                function update() {
                    // A/B stage
                    if (markA && !AB) {
                        var dNow = Math.hypot(x - markA.x, y - markA.y);
                        var eligible = dNow >= minDistForB;
                        if (eligible !== bEligible) { bEligible = eligible; }
                        var newStage = bEligible ? 'B' : 'A_wait';
                        if (newStage !== abStage) { abStage = newStage; updateABFab(); }
                    }

                    var usingGps = false;
                    if (gpsEnabled && gpsPose) {
                        usingGps = applyGpsPose();
                    }

                    if (!usingGps) {
                        // steering via keyboard/touch
                        var si = 0;
                        if (keys['ArrowLeft']) si -= 1;
                        if (keys['ArrowRight']) si += 1;
                        steer = si;

                        // speed model
                        if (keys['ArrowUp']) { v += accel * dt; cruiseOn = false; }
                        else if (keys['ArrowDown']) { v -= reverseAccel * dt; cruiseOn = false; }
                        else if (cruiseOn) {
                            if (v < cruiseSet - 0.02) v = Math.min(cruiseSet, v + accel * dt);
                            else if (v > cruiseSet + 0.02) v = Math.max(cruiseSet, v - reverseAccel * dt);
                        } else {
                            if (v > 0) v = Math.max(0, v - drag * dt);
                            else if (v < 0) v = Math.min(0, v + drag * dt);
                        }
                        v = Math.max(-5, Math.min(cruiseMax, v));

                        // integrate pose
                        var yaw = maxYawRate * steer * (0.6 + 0.4 * Math.min(1, Math.abs(v) / 10));
                        hdg += yaw * dt;
                        var vx = Math.sin(hdg) * v, vy = -Math.cos(hdg) * v;
                        x += vx * dt; y += vy * dt;
                    } else {
                        steer = 0;
                        cruiseOn = false;
                        if (typeof v !== 'number' || !isFinite(v)) v = 0;
                        else {
                            if (v > 30) v = 30;
                            if (v < -5) v = -5;
                        }
                    }

                    // implement articulation: rigid uses tractor heading; axle follows trailer kinematics
                    if (implementMode === 'rigid') {
                        implHdg = hdg;
                    } else {
                        var speed = Math.abs(v);
                        // effective length from hitch to implement's center of rotation (approx)
                        var L = Math.max(1.0, hitchOffset + 1.5);
                        // trailer differential: d(implHdg)/dt = (v/L) * sin(hdg - implHdg)
                        var rel = hdg - implHdg; rel = (rel + Math.PI) % (2 * Math.PI) - Math.PI;
                        var rate = (speed / L) * Math.sin(rel);
                        // clamp rate for stability/smoothness
                        if (rate > implMaxRate) rate = implMaxRate; else if (rate < -implMaxRate) rate = -implMaxRate;
                        implHdg += rate * dt;
                    }
                    // camera
                    if (follow) { var lerp = .15; camX += (x - camX) * lerp; camY += (y - camY) * lerp; }
                    var targetRot = (rotateOn && follow) ? hdg : 0; camRot = angleLerp(camRot, targetRot, 0.18);
                    // coverage
                    if (implement) {
                        var bar = currentImplementBar();
                        if (lastBar) {
                            if (!LOWPOWER || frameTick % 3 === 0) {
                                var quad = { l0: lastBar.L, r0: lastBar.R, l1: bar.L, r1: bar.R };
                                // area via polygon shoelace (l0->r0->r1->l1)
                                var ax = quad.l0.x, ay = quad.l0.y, bx = quad.r0.x, by = quad.r0.y, cx = quad.r1.x, cy = quad.r1.y, dx = quad.l1.x, dy = quad.l1.y;
                                var area = Math.abs((ax*by + bx*cy + cx*dy + dx*ay) - (ay*bx + by*cx + cy*dx + dy*ax)) * 0.5;
                                quad.a = area; // store per-quad area in m^2
                                coverageQuads.push(quad);
                                totalAreaM2 += area;
                                if (isFinite(coverageCap) && coverageQuads.length > coverageCap) {
                                    var nRemove = coverageQuads.length - coverageCap;
                                    var removed = coverageQuads.splice(0, nRemove);
                                    for (var ri = 0; ri < removed.length; ri++) totalAreaM2 -= (removed[ri].a || 0);
                                    if (totalAreaM2 < 0) totalAreaM2 = 0;
                                }
                            }
                        }
                        lastBar = bar;
                    } else {
                        lastBar = null;
                    }
                }
        // Draw
        function draw() {
        ctx.clearRect(0, 0, W, H);
        var ppm = pxPerM();

        // world space
        ctx.save();
        ctx.translate(W / 2, H / 2);
        ctx.rotate(-camRot);
        ctx.translate(-camX * ppm, -camY * ppm);

        // background
        ctx.fillStyle = (document.body.classList.contains('theme-day') ? '#ffffff' : '#155f25');
        ctx.fillRect((camX * ppm) - W * 2, (camY * ppm) - H * 2, W * 4, H * 4);

        // grid
        if (!LOWPOWER || (frameTick % 2 === 0)) {
        var step = (LOWPOWER ? 20 : 10) * ppm;
        ctx.beginPath();
        ctx.strokeStyle = (document.body.classList.contains('theme-day') ? 'rgba(0,0,0,.18)' : 'rgba(255,255,255,.14)');
        ctx.lineWidth = 1;
        for (var gx = (Math.floor((camX * ppm - W) / step) * step); gx < (camX * ppm + W); gx += step) {
        ctx.moveTo(gx, camY * ppm - H);
        ctx.lineTo(gx, camY * ppm + H);
        }
        for (var gy = (Math.floor((camY * ppm - H) / step) * step); gy < (camY * ppm + H); gy += step) {
        ctx.moveTo(camX * ppm - W, gy);
        ctx.lineTo(camX * ppm + W, gy);
        }
        ctx.stroke();
        }

        // AB passes (infinite span)
        if (AB) {
        var nx = Math.cos(AB.hdg), ny = Math.sin(AB.hdg);
        var ex = camX - AB.x0, ey = camY - AB.y0;
        var e_cam = ex * nx + ey * ny;
        var halfWm = (W / ppm) / 2, halfHm = (H / ppm) / 2;
        var r = Math.hypot(halfWm, halfHm) + passWidth * 2;
        var kMin = Math.floor((e_cam - r) / passWidth), kMax = Math.ceil((e_cam + r) / passWidth);
        // make guidance lines effectively infinite across the field
        var tx = Math.sin(AB.hdg), ty = -Math.cos(AB.hdg), span = 10000;
        for (var k = kMin; k <= kMax; k++) {
        var off = k * passWidth;
        var ox = AB.x0 + nx * off - tx * span, oy = AB.y0 + ny * off - ty * span;
        var ex2 = AB.x0 + nx * off + tx * span, ey2 = AB.y0 + ny * off + ty * span;
        ctx.beginPath();
        ctx.moveTo(ox * ppm, oy * ppm);
        ctx.lineTo(ex2 * ppm, ey2 * ppm);
        if (k === activePass) {
        ctx.save();
        ctx.strokeStyle = (document.body.classList.contains('theme-day') ? '#8B0000' : 'rgba(160,255,245,1)');
        ctx.lineWidth = LOWPOWER ? 4 : 6;
        if (!LOWPOWER) { ctx.shadowColor = 'rgba(140,240,218,0.85)'; ctx.shadowBlur = 16; }
        ctx.stroke();
        ctx.restore();
        } else {
        ctx.strokeStyle = (document.body.classList.contains('theme-day') ? 'rgba(139,0,0,0.6)' : 'rgba(160,255,245,.6)');
        ctx.lineWidth = 1.8;
        ctx.stroke();
        }
        }
        }

        // adjust tractor triangle size and tail anchor based on implement width
        (function(){ var dims = triDimsForWidth(passWidth); tractorTailBack = dims.tail; })();
        // coverage
        if (coverageQuads.length) {
        ctx.fillStyle = 'rgba(15,40,18,0.6)';
        for (var i = 0; i < coverageQuads.length; i++) {
        var q = coverageQuads[i];
        ctx.beginPath();
        ctx.moveTo(q.l0.x * ppm, q.l0.y * ppm);
        ctx.lineTo(q.r0.x * ppm, q.r0.y * ppm);
        ctx.lineTo(q.r1.x * ppm, q.r1.y * ppm);
        ctx.lineTo(q.l1.x * ppm, q.l1.y * ppm);
        ctx.closePath();
        ctx.fill();
        }
        }

        // implement link + bar (pivot from tail; link aligned with implement heading)
        var bar = currentImplementBar();
        var tailX = bar.T.x, tailY = bar.T.y;
        var hitchX = bar.H.x, hitchY = bar.H.y;
        ctx.beginPath(); ctx.moveTo(tailX * ppm, tailY * ppm); ctx.lineTo(hitchX * ppm, hitchY * ppm);
        ctx.strokeStyle = 'rgba(200,200,200,.7)'; ctx.lineWidth = 2; ctx.stroke();
        ctx.beginPath(); ctx.moveTo(bar.L.x * ppm, bar.L.y * ppm); ctx.lineTo(bar.R.x * ppm, bar.R.y * ppm);
        ctx.strokeStyle = '#ffd600'; ctx.lineWidth = 4; ctx.stroke();

        // tractor
        var _dims = triDimsForWidth(passWidth); var triL = _dims.L, triW = _dims.W;
        ctx.save(); ctx.translate(x * ppm, y * ppm); ctx.rotate(hdg);
        ctx.beginPath();
        ctx.moveTo(0, -triL * ppm * 0.6);
        ctx.lineTo(triW * ppm * 0.5, triL * ppm * 0.4);
        ctx.lineTo(-triW * ppm * 0.5, triL * ppm * 0.4);
        ctx.closePath();
        ctx.fillStyle = '#fff36b';
        if (!LOWPOWER) { ctx.shadowColor = '#fffbb5'; ctx.shadowBlur = 18; }
        ctx.fill();
        // black outline around tractor
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, -triL * ppm * 0.75); ctx.lineTo(0, -triL * ppm * 0.55);
        ctx.strokeStyle = 'rgba(0,0,0,.55)'; ctx.lineWidth = 3; ctx.stroke();
        ctx.restore();

        // A/B markers
        if (markA) { drawMarkerWorld(markA.x, markA.y, 'A', ppm); }
        if (markB) { drawMarkerWorld(markB.x, markB.y, 'B', ppm); }

        ctx.restore();

        // HUD text & LEDs
        var cte = cteRelativeToActivePass(x, y);
        var e;
        if ((e = document.getElementById('spdTxt'))) e.textContent = padFig((v * 3.6).toFixed(1), 4) + ' km/h';
        if ((e = document.getElementById('hdgTxt'))) e.textContent = padFig((((hdg * 180 / Math.PI) % 360 + 360) % 360).toFixed(0), 3) + '°';
        if ((e = document.getElementById('passTxt'))) e.textContent = padFig(activePass, 3);
        // Distance A→B
        var distMeters = null;
        if (typeof markA === 'object' && markA && typeof markB === 'object' && markB) {
            distMeters = Math.hypot(markB.x - markA.x, markB.y - markA.y);
        } else if (abDistanceMeters != null) {
            distMeters = abDistanceMeters;
        } else if (typeof markA === 'object' && markA) {
            // show live distance from A to current position while waiting for B
            distMeters = Math.hypot(x - markA.x, y - markA.y);
        }
        if ((e = document.getElementById('distTxt'))) {
            if (distMeters == null) e.textContent = padFig('-', 3) + ' m';
            else {
                e.textContent = padFig(distMeters.toFixed(0), 3) + ' m';
            }
        }
        // Worked area (ha)
        updateStatText(areaStatIds, padFig((totalAreaM2 / 10000).toFixed(2), 5) + ' ha');
        // Productivity (ha/h)
        var rate = passWidth * v * 0.36; // area rate
        updateStatText(rateStatIds, padFig(Math.round(rate), 3) + ' Ha/Val.');
        // Implement width (m)
        if ((e = document.getElementById('widthTxt'))) {
            var wtxt = passWidth.toFixed(2).replace(/\.00$/, '');
            var tgt = wtxt.indexOf('.') >= 0 ? 5 : 3;
            e.textContent = padFig(wtxt, tgt) + ' m';
        }
        updateLedBar(cte);
        }

        function drawMarkerWorld(wx, wy, label, ppm) {
        ctx.save();
        ctx.beginPath(); ctx.arc(wx * ppm, wy * ppm, 10, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0,200,255,.9)';
        if (!LOWPOWER) { ctx.shadowColor = 'rgba(0,200,255,.7)'; ctx.shadowBlur = 12; }
        ctx.fill();
        ctx.fillStyle = '#001018'; ctx.font = 'bold 12px Segoe UI,Arial';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(label, wx * ppm, wy * ppm);
        ctx.restore();
        }

        // GPS bridge API exposed globally for hardware integrations
        window.AgroGpsBridge = {
            enable: function () { setGpsEnabled(true); },
            disable: function () { setGpsEnabled(false); },
            setEnabled: function (flag) { setGpsEnabled(flag); },
            feed: function (sample, opts) {
                normalizeGpsSample(sample);
                if (!gpsEnabled && (!opts || opts.autoEnable !== false)) setGpsEnabled(true);
            },
            setOrigin: function (lat, lon) {
                if (lat && typeof lat === 'object') { lon = lat.lon; lat = lat.lat; }
                if (!isFinite(lat) || !isFinite(lon)) return;
                gpsOrigin = { lat: lat, lon: lon };
                notifyGpsState({ type: 'origin-set', origin: gpsOrigin, manual: true });
            },
            clearOrigin: resetGpsOrigin,
            getOrigin: function () { return gpsOrigin ? { lat: gpsOrigin.lat, lon: gpsOrigin.lon } : null; },
            isEnabled: function () { return gpsEnabled; },
            lastPose: function () { return gpsPose ? Object.assign({}, gpsPose) : null; },
            lastFixAgeMs: function () { return gpsLastFixMs ? performance.now() - gpsLastFixMs : Infinity; }
        };

        // Main loop
        var last = performance.now(), carry = 0;
        var target60 = 1000 / 60, target30 = 1000 / 30;
        if (isIE) LOWPOWER = true;
        function frame(now) {
        var elapsed = now - last; last = now;
        var target = LOWPOWER ? target30 : target60;
        carry += elapsed; if (carry < target) { requestAnimationFrame(frame); return; }
        carry = 0; frameTick++;
        var steps = Math.max(1, Math.min(5, Math.round((target / 1000) / dt)));
        for (var i = 0; i < steps; i++) update();
        draw();
        requestAnimationFrame(frame);
        }

        // init
        implHdg = hdg;
        camX = x; camY = y; camRot = rotateOn ? hdg : 0;
        updateFollowBtn(); updateRotateBtn(); updateLowPowerBtn();
        buildLeds(); refreshABStatus(); updateABFab(); updateImplementUI(); updateSimBtn();
        autoLiftControls();
        requestAnimationFrame(frame);
        })();
   </script>
 <script>
(function () {
  if (document.getElementById('dayNightToggle')) return;

  const THEME_DAY = 'day';
  const THEME_NIGHT = 'night';
  // Robust SVG icons to avoid encoding issues on some systems
  const SUN_SVG = "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' aria-hidden='true'><circle cx='12' cy='12' r='5'/><line x1='12' y1='1' x2='12' y2='3'/><line x1='12' y1='21' x2='12' y2='23'/><line x1='4.22' y1='4.22' x2='5.64' y2='5.64'/><line x1='18.36' y1='18.36' x2='19.78' y2='19.78'/><line x1='1' y1='12' x2='3' y2='12'/><line x1='21' y1='12' x2='23' y2='12'/><line x1='4.22' y1='19.78' x2='5.64' y2='18.36'/><line x1='18.36' y1='5.64' x2='19.78' y2='4.22'/></svg>";
  const MOON_SVG = "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' aria-hidden='true'><path d='M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z'/></svg>";

  const compute = (now) => {
    const hour = now.getHours();
    return hour >= 7 && hour < 19 ? THEME_DAY : THEME_NIGHT;
  };

  const nextBoundary = (now) => {
    const dayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const dayTime = new Date(dayStart.getFullYear(), dayStart.getMonth(), dayStart.getDate(), 7);
    const nightTime = new Date(dayStart.getFullYear(), dayStart.getMonth(), dayStart.getDate(), 19);
    if (now < dayTime) return dayTime;
    if (now < nightTime) return nightTime;
    return new Date(dayStart.getFullYear(), dayStart.getMonth(), dayStart.getDate() + 1, 7);
  };

  const apply = (mode) => {
    document.body.classList.toggle('theme-day', mode === THEME_DAY);
    document.body.classList.toggle('theme-night', mode === THEME_NIGHT);
    document.body.setAttribute('data-theme', mode);

    const icon = document.getElementById('theme-icon');
    if (icon) {
      icon.textContent = mode === THEME_DAY ? '☀' : '🌙';
      icon.setAttribute('data-theme-icon', mode);
    }
  };

  const setPref = (mode, until) => {
    try {
      localStorage.setItem('preferredTheme', mode);
      if (until) {
        localStorage.setItem('overrideUntil', String(until.getTime()));
      } else {
        localStorage.removeItem('overrideUntil');
      }
    } catch (err) {
      /* ignore */
    }
  };

  const getPref = () => {
    try {
      const rawUntil = localStorage.getItem('overrideUntil');
      const until = rawUntil ? Number(rawUntil) : 0;
      if (until && Date.now() < until) {
        return localStorage.getItem('preferredTheme');
      }
      localStorage.removeItem('overrideUntil');
      localStorage.removeItem('preferredTheme');
    } catch (err) {
      /* ignore */
    }
    return null;
  };

  // Inject proper day/night icons using SVG (robust across encodings)
  function renderThemeIcon(){
    try {
      var icon = document.getElementById('theme-icon');
      if (!icon) return;
      var isDay = document.body.classList.contains('theme-day');
      icon.innerHTML = isDay ? SUN_SVG : MOON_SVG;
    } catch(_){}
  }

  const findGear = () => {
    const selectors = [
      '#gear',
      '#settings',
      '#settingsBtn',
      '#settingsButton',
      '#btnSettings',
      '.gear',
      '.settings',
      '.settings-button',
      '.btn-settings',
      '.gear-icon',
      '[aria-label*=etting i]',
      '[title*=etting i]',
      '[data-icon=gear]',
      '.fa-gear',
      '.fa-cog',
      '.mdi-cog',
      '.icon-gear'
    ];
    for (const selector of selectors) {
      const match = document.querySelector(selector);
      if (match) return match;
    }
    const candidates = Array.from(document.querySelectorAll('button,a,i,span,div'));
    return candidates.find((el) => (el.textContent || '').toLowerCase().includes('settings')) || null;
  };

  const container = document.createElement('div');
  container.id = 'theme-toggle-container';
  container.className = 'theme-toggle-container';
  container.title = 'Diena/Naktis';

  const btn = document.createElement('button');
  btn.id = 'dayNightToggle';
  btn.type = 'button';
  btn.className = 'theme-toggle-btn';
  btn.setAttribute('aria-label', 'Perjungti dieną/naktį');

  const icon = document.createElement('span');
  icon.id = 'theme-icon';
  icon.className = 'theme-icon';
  icon.setAttribute('aria-hidden', 'true');
  btn.appendChild(icon);

  const clock = document.createElement('span');
  clock.id = 'theme-clock';
  clock.className = 'theme-clock';
  clock.textContent = '00:00:00';
  btn.appendChild(clock);

  container.appendChild(btn);

  const style = document.createElement('style');
  style.id = 'theme-toggle-styles';
  style.textContent = `
.theme-toggle-container{position:fixed;top:56px;right:12px;z-index:10000}
.theme-toggle-btn{display:inline-flex;align-items:center;gap:8px;padding:6px 12px;border-radius:8px;border:2px solid currentColor;cursor:pointer;font-weight:700;font-family:inherit}
.theme-icon{display:inline-flex;align-items:center;justify-content:center;width:22px;height:22px;font-size:18px;line-height:1;transition:transform .2s ease}
.theme-clock{font-variant-numeric:tabular-nums;letter-spacing:.5px;min-width:70px;text-align:center}
body.theme-day .theme-toggle-btn{background:#fff;color:#000}
body.theme-night .theme-toggle-btn{background:#0b3d0b;color:#fff}
body.theme-day,body.theme-day .app,body.theme-day #map,body.theme-day .map,body.theme-day .leaflet-container,body.theme-day .leaflet-control,body.theme-day .leaflet-bar a,body.theme-day .control,body.theme-day .controls,body.theme-day .control-panel,body.theme-day .mapboxgl-ctrl,body.theme-day .ol-control,body.theme-day input,body.theme-day select,body.theme-day textarea,body.theme-day button{background-color:#fff!important;color:#000!important;font-weight:700!important;border-color:#000!important}
body.theme-day a{color:#000!important;font-weight:700}
body.theme-night,body.theme-night .app,body.theme-night #map,body.theme-night .map,body.theme-night .leaflet-container,body.theme-night .leaflet-control,body.theme-night .leaflet-bar a,body.theme-night .control,body.theme-night .controls,body.theme-night .control-panel,body.theme-night .mapboxgl-ctrl,body.theme-night .ol-control,body.theme-night input,body.theme-night select,body.theme-night textarea,body.theme-night button{background-color:#0b3d0b!important;color:#fff!important;font-weight:700!important;border-color:#fff!important}
body.theme-night a{color:#fff!important;font-weight:700}
body.theme-night .leaflet-bar a,body.theme-day .leaflet-bar a{box-shadow:none!important}
body.theme-night .leaflet-popup,body.theme-day .leaflet-popup{background:inherit!important;color:inherit!important}
`;
  document.head.appendChild(style);

  const run = () => {
    const gear = findGear();
    if (gear && gear.parentElement) {
      container.style.position = 'static';
      container.style.top = '';
      container.style.right = '';
      gear.insertAdjacentElement('afterend', container);
    } else {
      document.body.appendChild(container);
    }

    const prefer = getPref();
    const initial = prefer || compute(new Date());
    apply(initial);
    renderThemeIcon();

    const clockSpan = document.getElementById('theme-clock');
    const tick = () => {
      const now = new Date();
      const formatted = now.toLocaleTimeString([], {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
      });
      if (clockSpan) {
        clockSpan.textContent = formatted;
      }
    };
    tick();
    setInterval(tick, 1000);

    setInterval(() => {
      const preferred = getPref() || compute(new Date());
      const current = document.body.classList.contains('theme-day') ? THEME_DAY : THEME_NIGHT;
      if (preferred !== current) {
        apply(preferred);
        renderThemeIcon();
      }
    }, 30000);

    btn.addEventListener('click', () => {
      const current = document.body.classList.contains('theme-day') ? THEME_DAY : THEME_NIGHT;
      const next = current === THEME_DAY ? THEME_NIGHT : THEME_DAY;
      apply(next);
      renderThemeIcon();
      setPref(next, nextBoundary(new Date()));
    });
  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', run);
  } else {
    run();
  }
})();
</script>
<script>
(function(){
  if (!window.AgroGpsBridge) { return; }
  var chip = document.getElementById('gpsChip');
  var statusEl = document.getElementById('gpsStatusText');
  if (!chip || !statusEl) { return; }

  var bridge = window.AgroGpsBridge;
  var ws = null;
  var reconnectTimer = null;
  var desired = true;
  var lastFix = null;

  var wsUrl = 'ws://192.168.4.1:81/';
  try {
    var saved = localStorage.getItem('gps.wsUrl');
    if (saved) wsUrl = saved;
  } catch (_) {}

  function setState(cls, text) {
    chip.classList.remove('gps-error','gps-connecting','gps-connected');
    chip.classList.add('gps');
    if (cls) chip.classList.add(cls);
    if (text) statusEl.textContent = text;
  }

  function summaryText() {
    var parts = [];
    var pose = bridge.lastPose && bridge.lastPose();
    if (lastFix && typeof lastFix.sats === 'number') {
      parts.push(lastFix.sats + ' sats');
    }
    var ageMs = bridge.lastFixAgeMs ? bridge.lastFixAgeMs() : Infinity;
    if (isFinite(ageMs)) {
      parts.push((ageMs / 1000).toFixed(1) + ' s');
    }
    return parts.join(' | ') || 'Prisijungta';
  }

  function updateFromBridge() {
    if (ws && ws.readyState === WebSocket.OPEN) {
      statusEl.textContent = summaryText();
    }
  }

  document.addEventListener('agro:gps-state', updateFromBridge);
  setInterval(updateFromBridge, 1000);

  function clearReconnect() {
    if (reconnectTimer) {
      clearTimeout(reconnectTimer);
      reconnectTimer = null;
    }
  }

  function scheduleReconnect() {
    if (!desired) return;
    if (reconnectTimer) return;
    reconnectTimer = setTimeout(function(){
      reconnectTimer = null;
      connect();
    }, 3500);
  }

  function connect() {
    if (!desired) return;
    clearReconnect();
    if (ws) {
      try { ws.close(); } catch (_) {}
      ws = null;
    }
    setState('gps-connecting', 'Jungiama...');
    try {
      ws = new WebSocket(wsUrl);
    } catch (err) {
      console.error('[GPS] net url', err);
      setState('gps-error', 'URL klaida');
      scheduleReconnect();
      return;
    }
    ws.onopen = function() {
      if (bridge.enable) bridge.enable();
      setState('gps-connected', summaryText());
    };
    ws.onmessage = function(evt) {
      try {
        var payload = JSON.parse(evt.data);
        lastFix = payload;
        if (bridge.feed) bridge.feed(payload);
        statusEl.textContent = summaryText();
      } catch (err) {
        console.error('[GPS] JSON klaida', err);
      }
    };
    ws.onerror = function() {
      setState('gps-error', 'Rysio klaida');
    };
    ws.onclose = function() {
      ws = null;
      if (desired && bridge.setEnabled) bridge.setEnabled(false);
      if (desired) {
        setState('gps-error', 'Atsijunge');
        scheduleReconnect();
      } else {
        setState('gps-error', 'Isjungta');
      }
    };
  }

  chip.addEventListener('click', function() {
    var next = prompt('NodeMCU WebSocket URL', wsUrl);
    if (!next) return;
    wsUrl = next.trim();
    try { localStorage.setItem('gps.wsUrl', wsUrl); } catch (_) {}
    desired = true;
    connect();
  });

  chip.addEventListener('contextmenu', function(e) {
    e.preventDefault();
    desired = !desired;
    if (!desired) {
      if (ws) { try { ws.close(); } catch (_) {} }
      setState('gps-error', 'Isjungta');
      if (bridge.setEnabled) bridge.setEnabled(false);
    } else {
      connect();
    }
  });

  setState('gps-error', 'Atsijunge');
  connect();
})();
</script>
</body>
</html>

<script>
(function(){
  function positionUnderGear(){
    var gear=document.querySelector('#menuToggle');
    var c=document.getElementById('theme-toggle-container');
    if(!gear||!c) return;
    var r=gear.getBoundingClientRect();
    c.style.position='fixed';
    c.style.left=Math.round(r.left)+'px';
    c.style.top=Math.round(r.top+r.height+8)+'px';
  }
  if(document.readyState==='loading'){
    document.addEventListener('DOMContentLoaded',positionUnderGear);
  }else{ positionUnderGear(); }
  window.addEventListener('resize',positionUnderGear);
  window.addEventListener('scroll',positionUnderGear,{passive:true});
})();
</script>
<style>
  /* Theme overrides: map + HUD + toggle */
  body.theme-day{background:#fff !important;color:#000 !important;}
  body.theme-day canvas#map{background:#fff !important;}
  body.theme-day .hud{background:rgba(255,255,255,0.45) !important;color:#000 !important;border-bottom:1px solid rgba(0,0,0,0.15) !important;}
  body.theme-day #theme-toggle-container .theme-toggle-btn{background:#fff;color:#000;border-color:#000}
  body.theme-day #fabAB{background:#1e88e5 !important;color:#fff !important;border-color:#1e88e5 !important;}
  body.theme-day #fabAB.fab-b{background:#00c853 !important;color:#fff !important;border-color:#00c853 !important;}
  body.theme-day #fabAB.fab-a-attn{background:#ff5252 !important;color:#fff !important;border-color:#ff5252 !important;}

  body.theme-night{background:#071309 !important;color:#fff !important;}
  body.theme-night canvas#map{background:#0b3d0b !important;}
  body.theme-night .hud{background:rgba(0,0,0,0.22) !important;color:#fff !important;border-bottom:1px solid rgba(255,255,255,0.14) !important;}
  body.theme-night #theme-toggle-container .theme-toggle-btn{background:#0b3d0b;color:#fff;border-color:#fff}
  body.theme-night #fabAB{background:#1e88e5 !important;color:#fff !important;border-color:#1e88e5 !important;}
  body.theme-night #fabAB.fab-b{background:#00c853 !important;color:#fff !important;border-color:#00c853 !important;}
  body.theme-night #fabAB.fab-a-attn{background:#ff5252 !important;color:#fff !important;border-color:#ff5252 !important;}
  /* Day mode explicit: gear/menu buttons */
  body.theme-day .menu-toggle{background:#fff !important;color:#000 !important;border-color:#000 !important;}
  body.theme-day .controls, body.theme-day .controls .group, body.theme-day .group-body{color:#000 !important;}
  body.theme-day .controls .btn, body.theme-day .group-body .btn{background:#fff !important;color:#000 !important;border-color:#000 !important;}
  body.theme-day .controls svg, body.theme-day .group .ico{color:#000 !important;}
</style>

/* Stripe + HUD + controls overrides (in-document style) */
<style id="fix-stripe-overrides">
  /* Make HUD and controls area fully transparent (no bar) */
  .hud{background:transparent !important;border-bottom:0 !important;box-shadow:none !important;backdrop-filter:none !important;-webkit-backdrop-filter:none !important;}
  body.theme-day .hud, body.theme-night .hud{background:transparent !important;}

  /* Remove any theme bar under controls */
  body.theme-day .controls, body.theme-night .controls,
  body.theme-day .control,  body.theme-night .control,
  .stats-row, .ledbar-wrap, .ledbar { background: transparent !important; box-shadow:none !important; border:0 !important; }

  /* Remove stripe/underline from group toggles */
  #btnGuideSettings,#btnImplSettings,#btnMapSettings{border-bottom:0 !important;}
  body.theme-night #btnGuideSettings,body.theme-night #btnImplSettings,body.theme-night #btnMapSettings,
  body.theme-day #btnGuideSettings,body.theme-day #btnImplSettings,body.theme-day #btnMapSettings{
    box-shadow:none !important; border-color:transparent !important; background:transparent !important;
  }
  #btnGuideSettings::after,#btnImplSettings::after,#btnMapSettings::after{content:none !important;}

  /* Keep day-mode labels/buttons white where requested */
  body.theme-day #btnGuideSettings, body.theme-day #btnImplSettings, body.theme-day #btnMapSettings{
    background:#fff !important; color:#000 !important; border-color:transparent !important;
  }

  /* Ensure canvas not painting an extra base behind HUD */
  canvas#map{background:transparent !important;}
</style>
<script>
(function(){
  var s=document.getElementById('fix-stripe-overrides');
  if(s && document.head && s.parentNode !== document.head){
    try{ document.head.appendChild(s); }catch(_){ }
  }
})();
</script>
<style id="menu-outline-buttons">
  /* Outline-style buttons in expandable menu */
  body.theme-day .group .group-body .btn,
  body.theme-night .group .group-body .btn { 
    background: transparent !important; 
    border: 2px solid currentColor !important; 
    border-radius: 12px !important; 
    color: inherit !important; 
    box-shadow: none !important;
  }
  body.theme-day .group .group-body .btn { color:#000 !important; }
  body.theme-night .group .group-body .btn { color:#fff !important; }

  /* Group toggle headers also look like buttons */
  body.theme-day .group .group-toggle,
  body.theme-night .group .group-toggle {
    background: transparent !important;
    border: 2px solid currentColor !important;
    border-radius: 12px !important;
    color: inherit !important;
    box-shadow: none !important;
  }
  body.theme-day .group .group-toggle { color:#000 !important; }
  body.theme-night .group .group-toggle { color:#fff !important; }

  /* Spin +/- pills inside number controls */
  body.theme-day .group .group-body .btn.spin,
  body.theme-night .group .group-body .btn.spin { border-radius: 9999px !important; }

  /* Subtle hover fills */
  body.theme-day .group .group-body .btn:hover,
  body.theme-day .group .group-toggle:hover { background: rgba(0,0,0,0.06) !important; }
  body.theme-night .group .group-body .btn:hover,
  body.theme-night .group .group-toggle:hover { background: rgba(255,255,255,0.08) !important; }

  /* Inputs match outline style */
  body.theme-day .group .group-body input[type="number"] { background: transparent !important; border: 2px solid #000 !important; color:#000 !important; border-radius:10px !important; }
  body.theme-night .group .group-body input[type="number"] { background: transparent !important; border: 2px solid #fff !important; color:#fff !important; border-radius:10px !important; }

  /* Ensure icons use currentColor */
  .group-toggle .ico { color: currentColor !important; stroke: currentColor !important; }
</style>

<style id="apply-toggle-restyle">
  /* Implement toggle vivid ON and grayed OFF */
  .apply-toggle.on { 
    background: #00e65a !important; 
    color: #fff !important; 
    border-color: rgba(0,0,0,.15) !important; 
    box-shadow: 0 0 0 6px rgba(0,230,90,.20), 0 18px 30px rgba(0,0,0,.40) !important; 
  }
  .apply-toggle.off { 
    background: #6a6a6a !important; 
    color: #eeeeee !important; 
    border-color: rgba(0,0,0,.25) !important; 
    box-shadow: none !important; 
  }
  /* Slight hover cue */
  .apply-toggle:hover { filter: brightness(1.05); }
</style>
<style id="apply-toggle-theme-override">
  body.theme-day #applyToggle.apply-toggle.on { background:#00e65a !important; color:#fff !important; border-color:rgba(0,0,0,.15) !important; }
  body.theme-day #applyToggle.apply-toggle.off { background:#9aa0a6 !important; color:#fff !important; border-color:rgba(0,0,0,.2) !important; }
  body.theme-night #applyToggle.apply-toggle.on { background:#00e65a !important; color:#fff !important; }
  body.theme-night #applyToggle.apply-toggle.off { background:#6a6a6a !important; color:#eeeeee !important; }
</style>
<style id="apply-toggle-icon-outline">
  /* Bigger implement icon with 1px black outline */
  #applyToggle .icon { 
    width: 48px !important; 
    height: 48px !important; 
    /* 1px faux stroke outline in all directions */
    filter: drop-shadow(0 1px 0 #000) drop-shadow(0 -1px 0 #000)
            drop-shadow(1px 0 0 #000) drop-shadow(-1px 0  #000);
  }
  @media (max-width: 900px) {
    #applyToggle .icon { width: 42px !important; height: 42px !important; }
  }
  @media (max-width: 600px) {
    #applyToggle .icon { width: 36px !important; height: 36px !important; }
  }
</style>


<style id="apply-toggle-icon-states">
  .apply-toggle.on .icon .trail { display:block; fill:#0a7a2a !important; stroke:none; }
  .apply-toggle.off .icon .trail { display:none; }
  .apply-toggle.off .icon .off-strike { display:block; stroke:#ff5252; stroke-width:2.5; stroke-linecap:round; }
  .apply-toggle.on .icon .off-strike { display:none; }
</style>




<style id="hud-day-blur">
  body.theme-day .hud{
    background: rgba(255,255,255,0.42) !important;
    backdrop-filter: blur(8px) saturate(1.05) !important;
    -webkit-backdrop-filter: blur(8px) saturate(1.05) !important;
    border-bottom: 1px solid rgba(0,0,0,0.12) !important;
    box-shadow: 0 8px 24px rgba(0,0,0,0.08) !important;
  }
</style>
<style id="hud-bottom-theme-overrides">
  .hud.hud-bottom{border-bottom:0 !important;}
  body.theme-day .hud.hud-bottom{border-bottom:0 !important;border-top:1px solid rgba(0,0,0,0.12) !important;}
  body.theme-night .hud.hud-bottom{border-bottom:0 !important;border-top:1px solid rgba(255,255,255,0.14) !important;}
</style>
<style id="group-toggle-outline-visibility">
  /* Day: rounded outline + black icons for collapsible buttons */
  body.theme-day #btnGuideSettings,
  body.theme-day #btnImplSettings,
  body.theme-day #btnMapSettings{
    background: transparent !important;
    color: #000 !important;
    border: 2px solid #000 !important;
    border-radius: 14px !important;
    box-shadow: 0 1px 0 rgba(0,0,0,0.06) !important;
  }
  body.theme-day #btnGuideSettings .ico,
  body.theme-day #btnImplSettings .ico,
  body.theme-day #btnMapSettings .ico,
  body.theme-day #btnGuideSettings svg,
  body.theme-day #btnImplSettings svg,
  body.theme-day #btnMapSettings svg{
    color: #000 !important; stroke: #000 !important;
  }
  /* Hide legacy pseudo-icons so inline SVG takes precedence */
  body.theme-day #btnGuideSettings.group-toggle::before,
  body.theme-day #btnImplSettings.group-toggle::before,
  body.theme-day #btnMapSettings.group-toggle::before{ display:inline-block !important; }

  /* Night: rounded outline + white icons for consistency */
  body.theme-night #btnGuideSettings,
  body.theme-night #btnImplSettings,
  body.theme-night #btnMapSettings{
    background: transparent !important;
    color: #fff !important;
    border: 2px solid #fff !important;
    border-radius: 14px !important;
  }
  body.theme-night #btnGuideSettings .ico,
  body.theme-night #btnImplSettings .ico,
  body.theme-night #btnMapSettings .ico,
  body.theme-night #btnGuideSettings svg,
  body.theme-night #btnImplSettings svg,
  body.theme-night #btnMapSettings svg{
    color: #fff !important; stroke: #fff !important;
  }
</style>
